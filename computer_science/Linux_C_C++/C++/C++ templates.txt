					基础
# C++中的转型的过程会创建一个新的局部临时变量
# 实参演绎dedution：也就是自动类型推导
# 函数模板也可以进行显式实例化
# 重载函数模板时，把改变限制在：显式指定模板参数 或 改变形参的个数
# 在声明中需要使用该类的类型时，必须使用stack<T>；而当使用类名而不是类的类型时，就应该只使用stack
# 遇到两个>>时，必须加空格，否则编译器会认为是operator>> (stack<stack<T> >)
# 类的全特化可以和基本类模板的实现完全不同: template <> class stack<int>;
# 类还可以偏特化
# 类定义的默认模板形参也可以引用之前的模板参数: template<typename T, typename CONT = std::vector<T> >
# 非类型模板参数: template <int size> 一般是常整数(包括枚举值)或者指向外部链接对象的指针；浮点数和类对象是不允许
	作为非类型模板参数的，内部链接对象(字符串)也不行，全局指针也不行
# 当某个依赖于模板参数的名称是一个类型时，就使用typename T::iterator
# .template和->template标记：标记某个类型是模板，这些标记也只能在模板中使用
# base class template有可能被特化，而那个特化版本可能不提供和一般性template相同的接口；因此编译器拒绝在
	templatized base classes内寻找继承而来的名称
# 成员函数模板可以支持模板的模板参数，但函数模板不支持
# 非引用模板形参，会把数组转换为指针；但是引用模板实参不行
# 模板的调试：可以定义一个类，进行动态追踪
# template-id：指的是模板名称与“紧随其后的尖括号内部的所有实参”

					深入
# 成员函数模板不能被声明为虚函数
# class T错误
# 非类型参数：一般是整型或枚举型、指针类型、引用类型
# 非类型模板参数的声明和变量的声明很相似，但它们不能用static和mutable修饰；可以用const、volatile修饰；
	如果限定的是最外层参数类型，编译器会忽略掉
# 模板参数而言，它的参数名称只能被自身其他参数的声明使用
# 类模板才能声明具有缺省模板实参，且缺省实参不能重复声明
# SFINAE原则：允许"试图"创建无效的类型(匹配不到)，但不允许"试图"计算无效的表达式
# 类型实参：
	局部类和局部枚举(在函数内部声明的类型)不能作为模板的类型实参；
	未命名的class或枚举类型不能作为模板的类型实参(using 后是可以的)
# 非类型实参：
	当实参匹配 "指针或引用类型的参数" 时，用户定义的类型转换和由派生类到基类的类型转换，都是不会被考虑的；
	唯一只能是：给实参关键字加上const或volatile
	空指针常量、浮点型值、字符串不能作为有效的非类型实参
	单一数组元素的地址、.运算符的变量，都是不可取的
# 模板实参的一个普遍约束是：在程序创建的时候，编译器或者链接器要能够确定实参的值
# 模板的模板实参 必须是一个类模板(struct、union都是有效实参)，且所有的模板参数要对应上
# 从函数模板产生的函数一定不会等于普通函数，即便这两个函数具有相同的类型和名称
# 从成员函数模板产生的函数永远也不会改写一个虚函数
# 从构造函数模板产生的构造函数一定不会是缺省的拷贝构造函数
# 类模板作为友元必须可见(模板函数无所谓)，普通类无要求
# 不能在友元声明中定义一个模板实例，最多只能定义一个特化；所以一个实例的友元声明是不能作为定义的
# 模板类/普通类 + 函数模板：
	非受限：也就是没有 :: 作用域符号
		对于普通函数，如果友元前见不到声明，则友元处就是该函数的第一次声明，因此可以定义
	受限：
		必须引用在此之前声明的函数或者函数模板，匹配的函数优先于函数模板，这样的友元声明不能定义
# 模板类 + 普通函数：
	对于类模板中定义友元普通函数，普通函数必须包含类模板的模板参数，否则会重复定义同一个函数
# 友元模板：类的所有全特化、偏特化均作为友元
# 受限查找：仅查找作用域之内的；
# 非受限查找：1、普通查找；2、ADL(依赖参数查找)：associated namespace、associated class中查找
	但在某一命名空间中using 另一命名空间时，using会被忽略
# 通常而言，友元声明在外围作用域中是不可见的；如果友元函数所在的类属于ADL的关联类集合，那么在外围类是可以
	找到该友元声明的
# 插入式类名称：在类本身作用域中插入该类的名称；可以被看做位于该类作用域中的一个非受限名称，而且是可访问名称
	使用::作用域符号访问
# 加入template关键字后，<>才不会被解析为比较运算符
# 非依赖型基类，派生类查找一个非受限名称，会先查找这个基类，再查找模板参数列表
# on-demand实例化(隐式/自动实例化)
	1、在使用模板特化的地方，编译器通常需要访问模板和某些模板成员的整个定义
# 延迟实例化
	1、在检查涉及到模板参数的约束时，编译器会假设该参数"处于最理想的情况"
	2、只对需要的部分进行实例化
# 显式实例化：template Info<int>; 为模板特化显式地生成POI
# 同一个程序中，每个特定的模板特化最多只能存在一处显式实例化；如果某个模板特化已经被显式实例化，那么就不能
	对它进行显式特殊化
# 实参演绎中：每个实参-参数对的分析都是独立的，如果最后得出结论发生矛盾，则演绎失败
# 匹配引用参数时，const和volatile是保留的
# 受限的类型名称不能被用来演绎T
# 全特化类模板时，如果类有默认实参，则全特化时这个默认实参可以不考虑进去；但全特化不能添加默认实参
# 全特化模板和由模板生成的实例化版本是不能够共存于同一个程序中的；头文件中的模板全特化，可以声明但不能定义，
	防止重复定义；如果是内联的，则可以在头文件中定义
# 定义全特化的类成员时，不需要添加template<>
# 除了全特化成员模板外，也可以对成员函数和普通的静态成员变量进行全特化；加上template<>前缀；除了成员函数
	和静态成员外，此特化的其他成员仍默认产生自原模板
# 针对类模板的特化成员，类外声明是允许的
# 偏特化
	1、偏特化的实参必须与基本模板的参数在种类上是匹配的
	2、参数列表不能具有缺省实参，但仍可以使用基本类模板的缺省实参
	3、偏特化的非类型实参不能是复杂的依赖型表达式
	4、参数列表不能和基本模板的参数列表完全相同
# metaprogramming是指借助于模板实例化机制，在编译期执行一些重要计算
# C++标注不允许给std命名空间增加新的模板，但允许特化其中的某个模板
# typeof运算符：编译期获取模板参数类型；但不会考虑协变返回类型：基类子类指针
# Modern C++ Design介绍了更多的TMP内容

					模板与设计
# 动多态：运行时判断类型；
# 静多态：不依赖于基类中包含公共行为的因素，但应用程序的不同 类型 都必须支持某些使用公共语法的操作；
	即模板函数中不同类调用不同函数作为多态
# 对于基于动多态的设计模式，静多态改写具有更好的性能
# 通过泛型操作，避免代码膨胀化(引入迭代器，避免每个stl类内均定义公共操作)
# trait可以表示主类型所关联的一些额外类型信息，但并不局限于类型，常数和其他类型的值也可以和一个类型进行关联
# 常量是在编译器进行求值的
# 在模板类的内部，C++只允许对const整型和枚举类型初始化成静态成员变量
# 枚举值不是左值，没有地址
# 表达式模板：刚开始是为了支持一种数值数组的类而引入的
# metaprogramming主要用于小的、大小固定的数组、而表达式模板则适用于能够在运行期确定大小、中等大小的数组
# 利用模板在编译期获取T的类型，称为编译期反射
# TMP中，应该使用enum(不会使用静态内存，将计算局限于完全的编译期结果)
# TMP中，使用的模板参数，都应该是编译期计算的变量(字面量、枚举、const integral、constexpr、traits、sizeof、alignof)


# traits设计
    struct tag1{};
    struct tag2{};
    template <class T>
    struct A {
        // 为结构体取别名
        using type = struct tag1;
        using type = T;
    }
    template <class T>
    class __info_traits {
        // 根据T的类型，来特判
        using type = typename T::type;
    };
    用__info_traits<T>::来使用traits
    void func(tag1 t);         func(__info_traits<T>::type);
    void func(tag2 t);

    template <class I>
    struct iterator_traits {
        using iterator_category = typename I::iterator_catgory;
        using value_type = typename I::value_type
        using difference_type = typename I::difference_type;
        using pointer = typename I::pointer;
        using reference = typename I::reference;
    };
# 只在内部使用的工具，前面加上前导符__，这些都是编译器保留字，用户下使用，后果字符...
# traits + 模板重载(某个参数不同) -》编译期静态重载
# 模板元一般需要类型推导：decltype(T1{} + T2{})
# if constexpr
    template <bool flag>
    void func() {
        if constexpr (flag) std::cout << "true\n";
    }
