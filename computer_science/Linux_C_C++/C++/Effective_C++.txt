# 构造函数声明为explicit，禁止编译器在构造类对象时进行隐式转换
# 命名规范：pw(pointer to weight)、rw(reference to weight)
# 以const、enum、inline替换#define，define可能被无意移去，不易debug
# 尽可能使用const，保证变量安全
# 对于类类型成员，列表初始化效率更高，内置类型无明显优化，但为了保持一致性
# 默认构造也进行列表初始化
# 构造函数很多时，考虑使用委托构造函数；且初始化顺序和声明顺序保持一致
# 多文件编程时，用local static替换non-local static，避免发生初始化次序问题
# C++ iostream程序库通过将拷贝构造声明到private中而且不实现它 来 阻止流的拷贝
# 也可以定义一个基类，声明拷贝为private，其他类private继承此类；基类可以不含虚析构
# 如果没有虚析构的话，销毁基类指针指向的子类对象，则该指针只会调用基类析构，析构基类成员；
	但如果有虚析构，则子类的析构重写基类析构，基类指针则可指向子类虚析构，并执行，析构所有成员
# 任何class只要带有virtual函数都几乎确定应该也有一个虚析构，因为既然有虚函数，则肯定会发生多态，多态必定会调用析构
# 纯虚析构需要类外定义
# 析构函数中捕获异常，异常不能跑出析构
# 构造和析构中不要调用虚函数，未被初始化，会调用基类虚函数
# 令operator=返回一个reference to
# 在operator=中处理自我赋值
# 拷贝时，基类成员不要忘记处理，显式调用基类构造函数钢化膜你吧
# 在类中管理内存，使用智能指针或自己定制；小心copy行为；提供访问内部资源的接口
# 用独立语句将new对象放入智能指针中
# 传递类类型形参时，以pass-by-reference-to-const代替pass-by-value传递
# pass-by-value不昂贵的代价的唯一对象：内置类型和STL的迭代器和函数对象
# 必须返回对象时，别妄想返回其reference
# 将成员变量声明为private，提高封装性
# 以non-member、non-friend函数替换member函数，可以将工具函数和该类放到一个命名空间里，各种功能的工具函数放到不同的头文件中
	与C++标准库的类似，只用导入特定头文件即可使用，也便于客户扩展
# std命名空间中禁止添加新的东西，using std::swap()可以使std中的swap可见
# 编译器优先选择自定义命名空间中的swap函数，其次选择std中的全特化版本，最后是一般化swap
# 在自定义命名空间中定义non-member的swap和member的swap，令non调用member；
# 为非模板类class进行swap全特化，定义中调用member函数
# 尽可能延后变量定义式的出现；且循环中最好将变量定义在循环内
# C++中的转型比C中的更易识别，作用范围也窄便于找错误
# 少做转型动作
# 避免返回reference或point指向对象内部成分
# copy-and-swap策略可以保证异常安全，但不保证整个函数有异常安全(连带影响)
# 异常安全只有 有或无 两种情况
# 编写异常安全码时，保证用对象管理资源，并且提供"异常安全三大保证"之一
# 为函数提供inline声明，仅仅只是向编译器提供申请
# 继承的子类构造和析构，其实内含基类构造析构，inline会增加成本，需要重新编译，麻烦
# 调试器中无法对inline函数进行调试
# 80-20经验法则：平均而言一个程序往往将80%的执行时间花费在20%代码上头；如果将这20%代码inline，效率会提高，但不好找
# 将文件间的编译依存关系降到最低，使用类的引用或指针
# 接口类：通常不带成员变量，也没有构造函数；只有一个虚析构函数和一组纯虚函数(带有纯虚函数的类是抽象基类)
# public继承是is-a模型，子类等同于基类，但基类不等同于子类，设计时考虑这个特性
# 如果子类函数覆盖了基类函数，如果不使用using Base::func();则无法调用基类的函数
# 可以为基类的纯虚函数提供定义，但是调用时必须指明类的作用域
# 声明一个pure-virtual的目的是为了让derived classes只继承函数接口
# 声明一个impure-virtual的目的，是让derived classes继承该函数的接口和缺省实现(非纯虚函数子类可以不重写)
# 声明non-virtual的目的是为了令derived classes继承函数的接口及一份强制性实现
# NVI手法：令客户通过public non-virtual成员函数间接调用private virtual函数；是模板设计模式的一种独特表现形式
# 绝不重新定义继承而来的缺省参数值
# 一个类含有其他类：has-a或is-implemented-in-terms-of
# private继承意味着is-implemented-in-terms-of，明智而谨慎地使用
# 虚继承效率很慢，里面不要放成员变量
# 模板中，C::const_iterator编译器不认为是一个类型，需要typename特别指定
# typename不可出现在base classes lists内的嵌套从属类型名称之前，也不可在member initialization list中作为base class修饰符
# 模板派生类不会寻找基类函数，除非在派生类中指定出来
# 将与参数无关的代码抽离templates
# 将copy构造函数泛化，以接收所有兼容类型；
# 泛化copy构造函数不会阻止编译器为你生成的默认构造，如果想要控制copy的方方面面，必须同时声明泛化和普通copy
# 模板参数不会对类进行隐式类型转换，需要将函数声明为友元后才能
# std::iterator_traits<>表现类型信息，迭代器类型
# 运行时选择：if语句；编译时选择：重载
# template metaprograms执行于C++编译期，可将工作由运行期转移到编译期；可导致较小的可执行文件、较短的运行期、较少内存需求，早期错误侦测
	但是编译时间增加了
# TMP的递归是：递归模板具现化