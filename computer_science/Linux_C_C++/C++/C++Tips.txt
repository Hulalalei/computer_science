=========================================C++11=============================================
										一、开始
#"C++"是一种静态类型语言，即：在编译阶段检查类型，检查类型的过程称为类型检查；编译器负责检查数据类型是否支持要执行的运算，
如果不支持，则编译器将报错且不会生成可执行文件，程序越复杂，静态类型检查越有助于发现问题

#在大多数系统中，main的返回值被用来指示状态；返回0表明成功，非0的返回值的含义由系统定义，通常用来
指出错误类型；访问main的返回值的方法依赖于系统，在UNIX和Windows系统中，执行完一个程序后，都可以
通过echo命令获得其返回值
UNIX中：echo $?
Windows中：echo %ERRORLEVEL%

#标准库iostream定义了四个IO对象，
标准输入：std::cin
标准输出：std::cout
标准错误：std::cerr，输出警告和错误信息
标准一般：std::clog，输出程序运行时的一般性信息
系统通常将程序所运行的窗口与这些对象关联起来

# #include指令和头文件的名字必须写在一行中，通常其必须出现在所有函数之外，一般都放在源文件开始位置

# << 输出运算符，左侧运算对象必须是ostream对象，右侧的运算对象是要打印的值，返回其左侧的运算对象

#std::endl是操纵符的特殊值，结束当前行，并将与设备关联的缓冲区中的内容刷新到设备中，在调试时添加
的打印语句，这类语句应该保证一直刷新流

#命名空间，避免不经意的名字冲突，标准库的定义的所有名字都在命名空间std中

#初始化：就是在变量创建的同时为它赋予一个值

#标注库定义了不同版本的输入输出运算符，来处理这些不同类型的运算对象，所以引入运算符重载不为过吧？
直接输出类对象
# /**/注释界定符最好能显式指出其内部的程序行都属于多行注释的一部分，一般注释内的每行都以一个星号开头
注释界定符不能嵌套

#包含来自标准库的头文件时，应该用尖括号包围头文件名，对于不属于标准库的头文件，则用双引号包围

										二、变量和基本类型
#double和float二者选double，两者计算代价相差无几

#可以通过添加前缀和后缀，来改变整型、浮点型和字符型字面值的默认类型

#某些常量加上某些前后缀后，可以变为相应的字面值，一种字面值对应一种数据类型
1、例如nullptr是指针的字面值，true和false是bool的字面值
2、比起字面值常量，使用const等定义的常量有一个可以称呼的名字，如const int a=2;名字就是a
3、字面值常量的"形式"和"值"决定了它的数据类型
4、和C中介绍的字面量一个意思

#列表初始化
int sold = 0;	int sold = {0};		int sold(0);
<C++11> -> int sold{0};	可以用这组花括号括起来的初始值进行初始化对象或为对象赋新值

#默认初始化
1、默认值由变量类型和定义变量的位置决定
2、内置类型的默认值由定义位置决定，定义于任何函数体之外的变量被初始化为0
3、每个类决定其各自的初始化方式，如果没有初始化就定义对象，那么类应该提供默认值
4、定义于函数体内的内置类型的对象如果没有初始化，则其值未定义；
5、类的对象如果没有显示的初始化，则其值由类确定(也就是无参构造去处理初始化)
6、建议初始化每一个内置类型的变量

#声明：extern int t;	同时进行初始化会引发错误
声明不会分配空间，定义时会分配空间

#标识符命名：
1、不能连续出现两个下划线
2、不能以下划线紧连大写字母开头
3、定义在函数体外的标识符不能以下划线开头
tip：变量用驼峰式书写，类开头大写

#::flag，向全局变量获取变量，覆盖默认的作用域规则

#引用
1、引用必须初始化，因为无法令引用重新绑定到另外一个对象；引用本身不是一个对象，没有地址，所以没有引用的引用
2、引用只能绑定对象，不能绑定字面值和表达式结果，类型也要与对象保持一致
	2.1 例外1：初始化常量引用时允许用(非常量也可)任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
	对于任意表达式，编译器会生成一个对应类型的临时量以此与引用匹配，此时绑定的是临时量

#nullptr字面量
<C++11> -> 指针字面值为nullptr，NULL为预处理变量；最好使用nullptr，尽量避免使用NULL

#void*指针可以指向内存地址，但不能访问内存

#基本数据类型是int而不是int*，*仅仅是类型修饰符；面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚
它的真实含义，如：int *&r = pt;

#默认情况下，const对象仅在文件内有效；如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern

#顶层const：表示指针本身是个常量；底层const：表示指针所指对象是一个常量
 顶层const可以表示任意的对象是常量，对任何数据类型都适用，底层const则与指针和引用等复合类型的基本类型部分有关

#常量表达式：指值不会改变并且在编译过程中就能得到计算结果的表达式；
const int sz = get_size();不是常量表达式，因为sz是在运行时才能获得到结果
<C++11> 为了得到常量表达式，标准规定允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式，
声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化；允许用constexpr函数来初始化

#字面值类型：算术类型、引用和指针都属于字面值类型；
1、constexpr指针的初始值必须是nullptr或0，或者是存储于某个固定地址中的对象
2、函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量；定义于所有函数体外的对象其
地址固定不变，能用来初始化constexpr指针；有效范围超出函数本身的变量也可以
3、constexpr仅对指针本身有效，与指针所指的对象无关

#类型别名
<C++11> 别名声明：using SI = name;
typedef char *pstring; const pstring cstr = 0;(顶层const)
声明语句中用到pstring时，其基本类型是指针

#<C++11> 引入auto类型说明符，让编译器替我们去分析表达式所属的类型
1、auto也能在一条语句中声明多个变量，该语句中所有变量的初始基本类型都必须一样
2、auto一般会忽略掉顶层const，同时底层const则会保留下来
3、如果希望推断出auto类型是一个顶层const，需要明确指出：const auto f = ci;
4、设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留

#<C++11> decltype类型指示符，让编译器分析表达式并得到它的类型，却不实际计算表达式的值
decltype(f()) sum = x;	//函数f的返回类型
1、如果decltype使用的表达式是一个变量，则decltype返回该变量的类型(包括顶层const和引用在内)
2、引用从来都作为其所指对象的同义词出现，只有用在decltype处是个例外
3、如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型
4、如果表达式是解引用操作，则decltype将得到引用类型(解引用指针可以得到指针所指对象，而且还能给这个对象赋值，
因此是引用类型)
5、decltype的结果类型与表达式形式密切相关，decltype((variable))的结果永远是引用，而decltype(variable)结果
只有当variable本身就是一个引用时才是引用

#自定义数据类型
1、类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号
必不可少：struct Sales_data {/* ... */} accum, trans, *salesptr; (不过不建议这样，容易混乱)
<C++11> 规定可以为数据成员提供一个"类内初始值"，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员
将被默认初始化

#类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样

#头文件保护符：#ifdef #ifndef等，最好设置一下

										三、字符串、向量和数组
#容器都有其各自的size_type类型值，用于下标访问(unsigned int类型)

#1、读取string遇到空白自动跳过
 2、当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符的两侧的运算对象至少
 有一个是string
 3、字符串字面值与string是不同类型

#一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到

#<C++11> 范围for：for (declaration : expression) statement
1、expression必须是一个序列(拥有能返回迭代器的begin和end成员)

#逻辑运算符，C++规定只有当左侧运算对象为真时才会检查右侧运算对象的情况

#1、引用不是对象，所以不存在包含引用的vector
 2、vector默认初始化是空容器
 <C++11> 提供了列表初始化vecotr：std::vector<std::string> articles = {"a", "an", "the"};
 3、通常情况下，可以只提供vector对象容纳的元素数量而略去初始值，此时库会创建一个值初始化的元素初值，并把它
 赋给容器中的所有元素，初值由容器中元素类型决定
 4、范围for语句体不应改变其所遍历序列的大小
 5、vector对象以及string对象的下标运算符可用于访问已存在的元素，而不能用于添加元素
 通过下标访问不存在的元素的行为就是所谓的缓冲区溢出
 6、任何一种可能改变vector对象容量的操作，都会使该vector对象的迭代器失效

#迭代器：有些没有定义<运算符；类型为：iterator或const_iterator
<C++11> 为了便于专门得到const_iterator类型的返回值，C++11标准引入了两个新函数，分别是cbegin和cend
1、但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素
2、difference_type带符号整型数，表示两个迭代器之间的距离

#数组：定义时必须指定数组类型，不允许用auto关键字由初始值的列表推断类型，不存在引用的数组
下标类型为size_t，一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小
1、auto推断数组类型时，返回的是指针；decltype推断时返回的是数组
<C++11> 为了使指针的使用更简单、更安全，C++11引入了begin和end函数，将数组作为它们的参数(定义在iterator头文件中)
2、ptrdiff_t一种带符号类型，表示数组指针之间的差值
3、下标可以小于0
4、可以用数组初始化vector

#1、C风格字符串尽量不要用，极易引发程序漏洞，是诸多安全问题的根本原因
 2、string对象不能直接初始化指向字符的指针

#现在的C++程序应尽量使用vector和迭代器，避免使用内置数组和指针；应尽量使用string，避免使用C风格基于数组的字符串

#要使用范围for语句处理多维数组，除了最内层的循环外，其他循环的控制变量都应该是引用类型，避免数组被转换成指针

#左值&右值：当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(内存中的位置)

#如果表达式的求值结果是左值，decltype(*pt)作用于该表达式得到一个引用类型int&；取地址运算符生成右值，decltype(&pt)的
结果是int **

										四、表达式
#<C++11> 规定，商一律向0取整
除了-m导致溢出的特殊情况，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)

#进行比较运算时除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象(因为bool会上升为int进行比较)

#<C++11> 允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象

#if (i = j)if语句的条件部分把j的值赋给i，然后检查赋值的结果(i)是否为真。如果j不为0，条件将为真

#除非必须，否则不用递增递减运算符的后置版本

#1、三目运算符优先级非常低，最好加括号
 2、移位运算符优先级不高不低，，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高

#<C++11> 允许用作用域运算符来获取类成员的大小sizeof(Sale_data::revenue);
1、对string对象或vector对象执行sizeof运算，只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间
#隐式转换
1、进行不同类型计算时，C++中不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值

#显式转换
1、命名的强制类型转换: cast-name<type>(expression);	->其中type是转换的目标类型而expression是要转换的值。如果
type是引用类型，则结果是左值；cast-name是static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种
2、static_cast：
	2.1 任何具有明确定义的类型转换，只要不包含底层const，都可以使用
	2.2 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用
	2.3 对于编译器无法自动执行的类型转换也非常有用，如：可以找回存在于void*指针中的值
3、const_cast：
	3.1 只能改变运算对象的底层const
	3.2 只有const_cast能改变表达式的常量属性
	3.3 不能用const_cast改变表达式的类型
	3.4 建议只在重载函数中使用
4、reinterpret_cast：
	4.1 通常为运算对象的位模式提供较低层次上的重新解释
	4.2 使用这个非常危险，要想安全使用，必须对涉及的类型和编译器实现转换的过程都非常了解
	4.3 类似于不考虑类型，直接强转

										五、语句
#switch中的case标签必须是整型常量表达式

#定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程

#for中的初始化变量，所有变量的基础类型必须相同(int i, j, k)

#do while中conditon不能为空，condition使用的变量必须定义在循环体外；如果在循环体内，则变量的使用出现在定义
之前，这显然是不合常理的

#goto如果往前跳到一个已经定义过的变量处时，会销毁此变量并重新创建

#throw runtime_error("");类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中；可以用字符串初始化
此类对象

#try catch(exception-declaration)	try语句块内声明的变量在块外部无法访问，特别是在catch子句内也无法访问
1、runtime_error::what()返回初始化的字符串
2、如果catch没有捕获到对应异常，或者没有try语句，则系统会调用terminate函数并终止当前程序的执行

#异常安全代码：那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全代码

#标准异常
1、exception头文件定义了最通用的异常类exception，只报告异常的发生，不提供任何额外信息
2、stdexcept头文件定义了几种常用的异常类
3、new头文件定义了bad_alloc异常类型
4、type_info头文件定义了bad_cast异常类型

										六、函数
#函数的形参中，即使两个形参的类型一样，也必须把两个类型都写出来
1、函数形参不能同名，函数内的变量不能与形参同名
2、函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针
3、形参在传入实参的时候进行定义并初始化
4、建议使用引用类型的形参替代指针
5、如果函数无需改变引用形参的值，最好将其声明为常量引用
7、当用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传给它常量对象或者非常量对象都是可以的

#自动对象：把只存在于块执行期间的对象称为自动对象
1、内置类型的局部静态变量初始化为0

#一个普通的引用必须用同类型的对象初始化；C++允许用字面值初始化常量引用；尽量使用常量引用

#可以用数组引用形参int (&arr)[10] 不过数组大小受到限制

#含有可变形参的函数
<C++11> 提供了两种方法
1、initializer_list：类似于容器，使用列表初始化，包含的元素是常量，传递实参时，用花括号包含；头文件同名
2、省略符：是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能；
	2.1 省略符不应该用于其他目的
	2.2 省略符形参应该仅仅用于C和C++通用类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝
	2.3 省略符只能出现在形参列表中的最后一个位置

#不要返回局部对象的引用或指针

#<C++11> 规定，函数可以返回花括号包围的值的列表；如果函数返回的是内置类型，则花括号包围的列表最多包含一个值

#允许main函数没有return语句直接结束，编译器隐式插入一条返回0的return语句
为了使返回值与机器无关，cstdlib头文件中定义了两个预处理变量：EXIT_FAILURE和EXIT_SUCCESS

#返回数组指针的函数声明：
	1、Type (*func(parameter_list)) [dimension]
	2、using arrT = int[10]; arrT* func(parameter)
	3、数组指针指向数组首地址，类似于二级指针

#<C++11> 尾置返回类型
1、可以简述返回数组指针的函数的声明的方法
2、任何函数的定义都能使用尾置返回
3、auto func(parameter) -> Type(*) [10];(箭头后是函数返回类型)

#函数重载
1、main函数不能重载
2、这些函数应该在形参数量或形参类型上有所不同
3、不允许两个函数除了返回类型外其他所有的要素都相同
4、顶层const形参，则两函数不能被编译器识别；底层const形参，则编译器可以识别
当传递非const参数时，编译器会优先选用非常量版本的函数
5、在不同的作用域中无法重载函数名：内层定义和外层函数名字相同的变量或函数，都会覆盖
6、名字查找发生在类型检查之前
7、如果传入可转换匹配类型的参数，则进行最佳匹配算法评定；如果等级相等，则函数存在二义性
8、调用重载函数时，应尽量避免强制类型转换

#默认实参
1、一旦某个形参被赋予了初始值，它后面的所有形参都必须有默认值
2、设计时，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面
3、默认实参声明：函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧所有形参必须都有默认值
4、局部变量不能作为默认实参

#constexpr函数
1、函数的返回类型及所有形参的类型都得是字面值类型
2、constexpr函数被隐式指定为内联函数
3、函数块中也可以包含其他语句，只要这些语句在运行时不执行任何操作
4、允许constexpr函数的返回值并非一个常量
constexpr int new_sz() {return 2;}
constexpr size_t scale(size_t cnt) {return new_sz() * cnt;}
5、内联函数和constexpr函数可以在程序中多次定义，但必须一致，所以放头文件里比较好

#调试工具
1、assert(expr)条件为假时调用abort()函数终止程序
2、#define NDEBUG可以关闭assert()，命令行中加上-D NDEBUG可以添加define

#函数指针
1、在指向不同函数类型的指针间不存在转换规则
2、可以为函数指针赋一个nullptr或者值为0的整型常量表达式
3、指向重载函数的指针，其类型应该与重载函数中的某一个精确匹配
4、decltype返回函数类型，此时不会将函数类型自动转换成指针类型
5、返回数组指针的函数声明：Type (*f(Type))(Type2)	Type2是返回的函数类型

										七、类
#1、成员函数的声明必须在类的内部，它的定义可以在类外或类内；接口组成部分的非成员函数，定义和声明都在类外
 2、定义在类内部的函数是隐式的inline函数，外部默认是非inline函数

#成员函数有额外的隐式参数this，调用函数时，会用该函数的对象(也就是类)地址来初始化this(常量指针，顶层const)

#C++允许把const关键字放在成员函数的参数列表之后，此时紧跟在参数列表后面的const表示this是一个指向常量的指针
这样使用的成员函数被称作常量成员函数
1、常量对象，以及常量对象的引用或指针都只能调用常量成员函数

#编译器首先编译成员的声明，然后才轮到成员函数体

#自定义运算符：当定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符

#IO类属于不能被拷贝的类型，函数中只能通过引用来传递它们

#构造函数
1、类可以包含多个构造函数，和其他重载函数差不多
2、构造函数不能被声明为const
3、构造函数在const对象的构造过程中可以向其写值

#默认构造函数
1、合成的默认构造函数：编译器创建的构造函数(没有显式声明时才创建)
	1.1 按如下规则初始化类的数据成员：
			1.1.1 如果存在类内的初始值，用它来初始化成员
			1.1.2 否则，默认初始化该成员
2、对于一个普通的类，必须定义它自己的默认构造函数
	2.1 如果不自己定义，容易得到未定义值
	2.2 可以控制对象初始化
	2.3 编译器可能不能为某些类合成默认的构造函数
3、<C++11> 如果我们需要默认的行为，那么可以通过在参数列表后面写上=default来要求编译器生成构造函数
=default既可以和声明一起出现在类内，也可以作为定义出现在类外

#构造函数初始值列表
1、负责为新创建的对象的数据成员赋初值
2、形参列表后：实参(形参), ... {}
3、列表中没有全部初始化，则剩余的进行默认初始化

#合成版本的运算：当类需要分配类对象之外的资源时，合成的版本常常会失效
1、很多需要动态内存的类能使用vector对象或者string对象管理必须的存储空间，能避免分配和释放内存带来的复杂性

#访问说明符
1、public：成员在整个程序内可被访问
2、protected：派生类有权访问基类成员，同时禁止其他用户访问
3、private：成员可以被类的成员函数访问，但是不能被使用类的代码访问

#使用class和struct定义唯一的区别就是默认的访问权限

#友元：允许其他类或者函数访问它的非公有成员
1、友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限
2、友元不是类的成员，也不受它所在区域访问控制级别的约束
3、一般来说，最好在类定义开始或结束前的位置集中声明友元
4、友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明；必须在友元声明外再专门对函数进行一次声明
5、友元关系不存在传递性，每个类负责控制自己的友元类或友元函数
6、如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明
7、类和非成员函数的声明不是必须在它们的友元声明之前；当第一个名字第一次出现在一个友元声明中时，隐式假定该名字
在当前作用域中是可见的；然而，友元本身不一定真的声明在当前作用域中
8、就算在类的内部定义了该友元函数，也必须在类的外部提供相应的声明从而使得函数可见

#类还可以自定义某种类型在类中的别名；由类定义的类型名字和其他成员一样存在访问权限；用来定义类型的成员必须先定义后使用

#对于可变数据成员，mutable，任何成员函数包括const函数在内都能改变它的值

#对于公用代码使用私有功能函数

#前向声明：class Screen;
1、不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明以不完全类型作为参数
或者返回类型的函数
2、类的成员类型不能是该类自己，但类允许包含指向它自身类型的引用或指针

#类的作用域
1、一旦遇到了类名，定义的剩余部分就在类的作用域之内了
2、函数返回类型出现在类名之前，在类的作用域之外，所有要想使用此类型，必须明确指定哪个类定义了它

#构造函数plus
1、如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始值列表为这些成员提供初值
2、在很多类中，初始化和赋值的区别事关底层效率问题
3、建议养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误
4、成员的初始化顺序与它们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序
5、最好令构造函数初始值的顺序与成员声明的顺序保持一致，而且如果可能，尽量避免使用某些成员初始化其他成员

#委托构造函数
<C++11> 扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数；一个委托构造函数使用它所属类的其他构造
函数执行它自己的初始化过程，或者说它把它自己的一些职责委托给了其他构造函数
1、参数列表必须与类中另外一个构造函数匹配：Sales_data(): Sales_data("", 0, 0) {}
2、当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体依次执行；假如函数体包含有代码的话，
将先执行这些代码，然后控制权才交还给委托者的函数体

#转换构造函数
1、只允许一步类类型转换：item.combine(string("9-999"));
2、可以通过将构造函数声明为explicit加以阻止，此关键字只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行
隐式转换
3、只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复
4、explicit构造函数只能用于直接初始化
5、尽管编译器不会将explicit的构造函数用于隐式转换过程，但是可以使用这样的构造函数进行显式的强制进行转换：
item.combine(Sales_data(null_book));

#聚合类
1、聚合定义：
	1) 所有成员都是public的
	2) 没有定义任何构造函数
	3) 没有类内初始值
	4) 没有基类，也没有virtual函数
2、字面值常量类
	2.1 数据成员都是字面值类型的聚合类是字面值常量类；如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类
	1) 数据成员都必须是字面值类型
	2) 类必须至少含有一个constexpr构造函数
	3) 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则
	初始值必须使用成员自己的constexpr构造函数
	4) 类必须使用析构函数的默认定义，该成员负责销毁类的对象
	2.2 尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数；事实上，一个字面值常量类必须
	至少提供一个constexpr构造函数

#类的静态成员
1、类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据
2、静态成员函数也不与任何对象绑定在一起，它们不包含this指针
3、作为结果，静态成员不能声明成const的，也不能在static函数体内使用this指针
4、仍然可以使用类的对象、引用或者指针来访问静态成员
5、成员函数不用通过作用域运算符就能直接使用静态成员
6、既可以在类的内部也可以在类的外部定义静态成员函数，static关键字只出现在类内部的声明语句
7、不是由构造函数初始化的，也不能在类的内部初始化静态成员；必须在类的外部定义和初始化每个静态成员
8、可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr
9、如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义
如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了
10、即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员
11、静态数据成员可以是不完全类型，也可以使用静态成员作为默认参数
12、类名作用域运算符不能访问非static成员
										八、IO库
#头文件							类型
iostream						istream，wistream
								ostream，wostream
								iostream，wiostream

fstream							ifstream，wifstream
								ofstream，wofstream
								fstream，wfstream

sstream							istringstream，wistringstream
								ostringstream，wostringstream
								stringstream，wstringstream

#类型ifstream和istringstream都继承自istream，类似的，类型ofstream和ostringstream都继承自ostream

#IO对象
1、IO对象不能拷贝，也不能将形参或返回类型设置为流类型
2、进行IO操作的函数通常以引用方式 传递和返回 流
3、读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的

#访问和操纵流的状态	P279

#流一旦发生错误，其上后续的IO操作都会失败；确定一个流对象的状态的最简单的方法是将它当作一个条件来使用

#导致IO缓冲刷新的原因
1、程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行
2、缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区
3、可以使用操纵符如endl来显式刷新缓冲区
4、在每个输出操作之后，可以用操纵符unitbuf设置流的内部状态，来清空缓冲区；默认情况下，对cerr设置是unitbuf的
因此写到cerr的内容都是立即刷新的
5、一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新
exception：当一个程序异常终止时，输出缓冲区是不会被刷新的

#flush刷新缓冲区，endl刷新缓冲区并加上一个换行

#unitbuf
如果想在每次输出操作后都刷新缓冲区，可以使用此符；它告诉流在接下来大的每次写操作之后都进行依次flush操作；
而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制

#tie()
1、无参：如果本对象当前关联到一个输出流，则返回指向这个流的指针；如果未关联到流，则返回空指针
2、带参(指向ostream的指针)：将自己关联到此ostream
tip：每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream
解开流的关联时，只需传递一个空指针即可

#文件IO函数
fstream fstrm(s, mode);	open会被自动调用
fstrm.open(s);
fstrm.close();
fstrm.is_open();

#文件的打开与关闭
1、if(cout)来判断一个流是否被打开成功
2、对一个已经打开的文件流调用open会失败，随后试图使用文件流的操作都会失败
3、为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件
4、一旦文件功能关闭，可以打开新的文件
5、当一个fstream对象被销毁时，close会自动被调用

#文件模式
1、in	以读方式打开
2、out	以写方式打开
3、app	每次写操作前均定位到文件结尾
4、ate	打开文件后立即定位到文件末尾
5、trunc	截断文件
6、binary	以二进制方式进行IO
tip：通过|符号来组合多种模式

#字符串IO函数
1、sstream strm(s);
2、strm.str();
3、strm.str(s);

										九、顺序容器
#顺序容器类型
1、vector：可变大小数组，支持快速随机访问；是栈类型
2、deque：双端队列，支持快速随机访问
3、list：双向链表；只支持双向随机访问
4、forward_list：单向链表，只支持单向顺序访问
5、array：固定大小数组，支持快速随机访问，不能添加或删除元素
6、string：随机访问快，在尾部插入或删除速度快
<C++11> forward_list和array是C++11标注增加的类型

#顺序容器选择基本原则
1、除非有更好的选择，否则应使用vector
2、如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list
3、如果程序要求随机访问元素，应使用vector或deque
4、如果程序要求在容器的中间插入或删除元素，应使用list或forward_list
5、如果程序只要在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
	--首先，确定是否真的需要在容器中间位置添加元素；当处理输入数据时，通常可以很容易地向vector追加数据，然后
	再调用标准库地sort函数来重排容器中地元素，从而避免在中间位置添加元素
	--如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中地内容拷贝到一个vector中
tip：选取容器类型时，有时对其性能进行测试是必要地

#对于容器存储的类类型时，如果类没有默认构造函数，则初始化容器时必须提供初始化器

#<C++11> 规定可以用auto与begin和end函数结合使用

#每个容器类型都定义了默认构造函数，会创建一个指定类型的容器(array除外)

#容器拷贝
1、当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了，而且新容器和原容器中的元素类型也可以不同，
只要能将要拷贝的元素转换为要初始化的容器的元素类型即可
2、当一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同
3、虽然不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制
4、容器1 = 容器2，左边容器将与右边容器相等

#emplace
1、调用一个emplace成员函数时，是将参数传递给元素类型的构造函数；emplace成员使用这些参数在容器管理的内存空间
中直接构造函数
c.emplace("99-999", 25, 15.00);
c.push_back("99-999", 25, 15.00);

#访问元素
1、front和back函数分别返回首元素和尾元素的引用
2、容器中访问元素的成员函数(front、back、下标、at)返回的都是引用
3、如果容器是一个const对象，则返回值是const的引用

#内存分配策略
1、必须遵守的原则是：只有当迫不得已时才可以分配新的内存空间

#<C++11> 新标准引入了多个函数，可以实现数值数据与标准库string之间的转换
to_string(val); stoi(); stol(); ......

#容器适配器
1、类型：stack<>、queue<>、priority_queue<>
2、所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在array之上
3、也不能用forward_list来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力
4、stack要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack
5、queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque上，但不能基于vector
6、priority_queue除了front、push_back和pop_back操作之外还要求随机访问额能力，因此它可以构造于vector或deque
之上，但不能基于list构造

										十、泛型算法
#include <algorithm>
#include <numeric>
#只读算法
1、find(begin(), end(), val);
2、accumulate(begin(), end(), init);	可以对类进行求和
3、equal(v1.begin(), v1.end(), v2.begin());	假定第二个序列至少与第一个序列一样长
tip：那些只接收一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长

#写容器元素算法
1、fill(vec.begin(), vec.end(), 0);
2、fill_n(vec.begin(), vec.size(), 0);
tip：向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素
#include <iterator>	back_inserter();
3、fill_n(back_inserter(vec), 10, 0);

#拷贝算法
1、copy(v1.begin(), v1.end(), v2.begin());
2、replace(v1.begin(), v1.end(), res, dest);
3、replace_copy(v1.begin(), v1.end(), back_inserter(vec), res, dest);

#重排算法
1、sort(v.begin(), v.end());
2、unique(v.begin(), v.end());	所有不重复的元素排在前面，重复的被覆盖掉，剩下的位置元素未知
3、sort(v.begin(), v.end(), )
tip：谓词类似于函数指针
一元谓词：谓词这个函数接受一个参数
二元谓词：谓词这个函数接受两个参数
4、stable_sort(v.begin(), v.end(), type (*func)())稳定排序

#lambda表达式
	1、由于有些算法需要一元谓词，但一元谓词不能满足排序条件，这时便引入了lambda表达式(捕获列表可以捕获很多变量)
	2、一个lambda表达式表示一个可调用的代码单元(未命名的内联函数)
	3、[capture list] (parameter list) -> return type { function body };
		3.1 capture list是一个lambda所在函数中定义的(非static)局部变量的列表
		3.2 可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体：auto f = [] { return 42; }
		3.3 调用方式：f();
	4、如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void
	5、lambda不能有默认实参
	6、lambda可以直接使用局部static变量和它所在函数之外声明的名字
lambda的捕获与返回
	1、变量的捕获方式也可以是值或引用
		1.1 值捕获
			1.1.1 与传值参数类似，采用值捕获的前提是变量可以拷贝
			1.1.2 与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝，因此随后对其修改不会影响到
			lambda内对于的值
		1.2 引用捕获
			1.2.1 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的
	2、应该尽量减少捕获的数据量，应该避免捕获指针或引用
	3、隐式捕获
		3.1 在捕获列表中写一个&或=指示编译器推断捕获列表(&表示引用捕获，=表示值捕获)
		3.2 混合捕获
			3.2.1 捕获列表的第一个元素必须是一个&或=
			3.2.2 显式捕获的变量必须使用与隐式捕获不同的方式(如果隐式捕获是&，则显式捕获变量必须是=)
可变lambda
1、在参数列表首加上关键字mutable：[v1] () mutable { return ++v1; };

#参数绑定
当排序算法需要一元谓词，我们想要用普通函数对其进行近似lambda时，可以使用函数绑定
#include <functional>
	1、<C++11> 可以解决向函数传递一个长度参数的问题，方法是使用一个新的名为bind标准库函数，可以将其看作函数适配器
	它接受一个可调用对象，生成一个新的可调用对象
	2、语法：auto newCallable = bind(callable, args_list);
	3、args_list的参数格式为_n，_1为newCallable的第一个参数......以此类推
	4、应用：对于一个二元谓词，auto check = bind(check_size, _1, sz);
	check中sz作为默认参数，_1作为一元谓词
	5、_n在命名空间std::placeholders中
	6、可以使用bind重排参数
绑定引用参数
1、必须使用标准库ref函数或cref函数，都在上面头文件中；
2、函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的
语法：for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));

#迭代器适配器
1、插入迭代器
	1.1 通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素
	1.2 操作：
		1.2.1 it = t; 向it指向的位置插入值t
		1.2.2 *it, ++it, it++; 这些操作虽然存在，但是不会对it做任何事情，每个操作都返回it
	1.3 类型：back_inserter、front_inserter、inserter
	1.4 语法：auto it = inserter(container, iter);
2、iostream迭代器
	这些迭代器将它们对应的流当作一个特定类型的元素序列来处理
	2.1 istream迭代器
		2.1.1 操作：
			istream_iterator<T> in(cin);
			istream_iterator<T> end;
			in1 == in2
			in1 != in2
			*in
			in->item
			++in, in++
		2.1.2 end被定义为空的istream_iterator，对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或
		遇到IO错误，迭代器的值就与尾后迭代器相等
		2.1.3 从迭代器范围构造vec：vector<int> vec(in_iner, eof);
		2.1.4 允许惰性求值，标准库并不保证迭代器立即从流读取数据，具体实现可以推迟从流中读取数据，直到我们
		使用迭代器时才真正读取；标准库所保证的是：在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了
	2.2 ostream_iterator迭代器
		2.2.1 操作：
			ostream_iterator<T> out(cout);
			ostream_iterator<T> out(cout, s);	s为字符数组串，每次输出都会输出s
			out = val;
			*out, ++out, out++; 不对out做任何事情，每个运算符都返回out；但还是推荐这样写，便于移植
3、反向迭代器
	3.1 可以通过调用rbegin、rend、crbegin、crend成员函数来获得反向迭代器
	3.2 流迭代器不支持递减运算，因为不可能在流中反向移动，因此不可能从一个forward_list或一个流迭代器
	创建反向迭代器
	3.3 通过调用reverse_iterator的base成员函数来完成这一转换

#泛型算法结构
1、算法所要求的迭代器操作可以分为5个迭代器类别
						迭代器类别
输入迭代器								只读，不写；单遍扫描，只能递增
输出迭代器								只写，不读；单遍扫描，只能递增
前向迭代器								可读写；多遍扫描，只能递增
双向扫描								可读写；多遍扫描，可递增递减
随机访问迭代器							可读写，多遍扫描，支持全部迭代器运算
2、C++标准指明了泛型和数值算法的每个迭代器参数的最小类别，对每个迭代器参数来说，其能力必须与规定的最小类别
至少相当，向算法传递一个能力更差的迭代器会产生错误(编译器不会给出警告)
	2.1 算法find和accumulate要求输入迭代器
	2.2 copy函数的第三个参数就是输出迭代器
	2.3 算法replace要求前向迭代器
	2.4 算法reverse要求双向迭代器
	2.5 算法sort要求随机访问迭代器

#算法形参模式
在任何其他算法分类之上，大多数算法具有如下4种形式之一：
1、alg(beg, end, other args);
2、alg(beg, end, dest, other args);
3、alg(beg, end, beg2, other args);
4、alg(beg, end, beg2, end2, other args);

#算法命名规范
算法还遵循一套命名和重载规范
1、一些算法通过重载形式传递一个谓词，接受谓词参数重载 < 或 == 运算符
2、_if版本的算法：接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值；
接受谓词参数的算法，一般都附加的_if前缀
3、默认情况下，重排算法将重排后的元素写回给定的输入序列中，也提供了其他版本将元素写到一个指定的输出目的位置
如：_copy, _if

#特定容器算法
1、链表类型list和forward_list定义了几个成员函数形式的算法
2、链表类型定义的其他算法的通用版本可以用于链表，但是代价太高，因此这些成员算法性能比对应的通用版本好得多
3、链表版本会改变底层的容器

										十一、关联容器
#include <map>	include <set>	include <unordered_map>  include <unordered_set>

#关联容器也可以进行列表初始化，关联容器的迭代器都是双向的
1、map需要指定关键字类型和值的类型，而set只需要指定关键字类型，因为set中没有值
2、可以用拷贝初始化，也可以用范围初始化
3、map元素格式：{key, value} 或 std::pair<keyType, valueType>(key, value)
4、有序容器必须定义元素比较的方法，默认标准库使用关键字类型的 < 运算符比较关键字
5、集合类型中，关键字类型就是元素类型；映射类型中，关键字类型是元素的第一部分的类型
6、容器自定义比较
	6.1 需要在尖括号中紧跟着元素类型给出	std::map<int, int, bool> maps([]() -> bool { return true; });
	6.2 自定义排序后，find和insert函数均不能使用；
	6.3 在类内自定义容器排序规则时，须在构造函数中进行自定义: 
		ThreadPool(): workerMaps([]() -> bool {return true; }) {}

#pair<type1, type2>类型
1、默认对数据成员进行值初始化
2、数据成员是public的(first, second)
3、也可以作为返回类型：return {key1, key2};

#key和value类型：
1、key_type：此容器类型的关键字类型
2、mapped_type：每个关键字关联的类型；只适用于map
3、value_type：对于set，与key_type相同；对于map，为pair<const key_type, mapped_type>

#操作：
1、insert，只对第一个带此关键字的元素进行插入操作

										十二、智能指针
#智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象
#include <memory>
1、shared_ptr：允许多个指针指向同一个对象
2、unique_ptr：的独占所指向的对象
3、weak_ptr：伴随类，是一种弱引用，指向shared_ptr所管理的对象
4、智能指针的默认初始化是空指针
5、智能指针都有计数器，当计数器为0时，会释放其管理的原内存
6、最安全的分配和使用动态内存的方法是使用make_shared<T>(args)来初始化智能指针
7、拷贝一个shared_ptr，计数器会递增；给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减
8、可以用new初始化智能指针：shared_ptr<int> p1(new int(1024));	因为接受指针参数的智能指针构造函数是explicit的
不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针
9、一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象
10、不要混合使用内置指针和智能指针
11、make_shared可以在分配对象时将shared_ptr与之绑定，如果是new来初始化，则创建的智能指针的相互独立的
12、永远不要用智能指针的get()来初始化另一个智能指针或为另一个智能指针赋值
13、智能指针在被销毁后会调用析构函数，释放内存空间，防止内存泄露；也可以应用到其他方面，比如对于一个对象的
开启与关闭，即使程序异常终止，析构函数也会执行

#shared_ptr方法
1、shared_ptr<T> p(q)		p管理内置指针q所指向的对象
2、shared_ptr<T> p(u)		p从unique_ptr u那里替换了对象的所有权；将u置空
3、shared_ptr<T> p(q, d)	p接管了内置指针或智能指针q所指向的对象的所有权；p将使用可调用对象d来代替delete
4、p.reset(q, d)		若p是唯一指向其对象的shared_ptr，reset会释放此对象；若传递了可选的参数内置指针q，
会令p指向q，否则会将p置为空；若还传递了参数d，将会调用d而不是delete

#直接管理内存new、delete
1、动态分配的对象是默认初始化的
2、可以使用直接初始化的方式来初始化动态分配对象
3、可以使用列表初始化：std::vector<int> *pt = new std::vector<int> {1, 2, 3};
4、可以进行值初始化，只需在类型名之后跟一对空括号即可：int *pt = new int();
5、auto p1 = new auto(obj)具有单一初始化器才可以使用

#定位new
#include <new>
1、int *p1 = new (nothrow) int; nothrow为对象，可以防止内存不够用时，new抛出std::bad_alloc异常
2、由内置指针管理的动态内存在被显式释放前一直都会存在

#内存泄漏
1、忘记释放动态内存会导致内存泄漏，因为这种内存永远不可能被归还给自由空间了，且只有在内存空间真正耗尽的时候
才能检测出这种错误
2、连续释放两次空间，则自由空间可能会被破坏
3、销毁指针后，其内存和地址都必须进行适当处理

#unique_ptr
1、某个时刻只能有一个unique_ptr指向一个给定对象，当此指针被销毁时，它所指向的对象也被销毁
2、没有类似make_shared的标准库函数返回一个unique_ptr
3、当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上，初始化时必须直接初始化
4、不支持普通的拷贝或赋值操作，但可以通过调用release或reset将指针的所有权从一个非const unique_ptr转移给另一个unique
有一个特例是：可以拷贝或赋值一个将要被销毁的unique_ptr
5、如果不用另一个智能指针来保存release返回的指针，则程序就要负责资源的释放，release仅仅切断指向，但不会释放内存
6、auto_ptr类：具有unique_ptr部分特性，但不是全部；不能在容器中保存auto_ptr，也不能从函数中返回auto_ptr
7、删除器：在尖括号中unique_ptr指向类型之后提供删除器类型：unique_ptr<objT, delT> p (new objT, fcn);
8、unique_ptr<T, D> u(d);

#weak_ptr
1、是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象
2、将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象
就会被释放，即使有weak_ptr指向对象，对象也还是会被释放，因此weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点
3、weak需要shared初始化
4、访问对象时需要调用lock对象返回的shared指针
5、可以阻止用户访问一个不再存在的内存的企图

#动态数组
1、int *pia = new int[get_size()];	方括号中的大小必须是整形，但不必是常量；返回指向第一个对象的指针
<C++11> 动态数组不是数组类型，不能调用begin和end，也不能用范围for
2、默认情况下，new分配的对象不管是单个分配的还是数组中的，都是默认初始化的，可以对数组中的元素进行值初始化，也
可以列表初始化；不能用auto分配数组
3、动态分配一个空数组是合法的
4、delete []p;	销毁p指向的数组中的元素，并释放对应的内存，数组中的元素按逆序销毁；如果delete p，其行为是未定义的
5、标准库提供了用unique管理new分配的数组的方式
unique_ptr<int[]> up(new int[10]);	//up指向一个包含10个为初始化int的数组
up.release();				//自动用delete[]销毁其指针
可以用下标访问数组
6、shared_ptr不直接支持管理动态数组，如果希望管理，则必须提供自己定义的删除器
shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算

#allocator类
1、new将内存分配与对象构造组合在了一起；delete将对象析构和内存释放组合在了一起
2、当分配一大块内存时，我们通常计划在这块内存上按需构造对象，在此情况下，我们希望将内存分配和对象构造分离
一般情况下将内存分配和对象构造组合在一起可能会导致不必要的浪费
3、#include <memory>	allocator将内存分配和对象构造分离开来
4、还提供有伴随拷贝算法，如将容器范围中的元素拷贝到目的内存中
方法：
1、alloctor<T> a;					为类型T的对象分配内存
2、a.allocate(n);					分配一段原始未构造的内存，保存n个T类型对象
3、a.deallocate(p, n);				释放从T*指针p中地址开始的内存；p必须是一个先前由allocate返回的指针，且n必须是
									p创建时所要求的大小；调用之前必须对每个在这块内存中创建的对象调用destroy
4、a.construct(p, args);			p必须是一个类型为T*的指针，指向一块原始内存；arg被传递给类型为T的构造函数，用来
									在p指向的内存中构造一个对象
5、a.destroy(p);					对p指向的对象执行析构函数
6、uninitialized_copy(b, e, b2);	从迭代器(b, e)范围内的元素拷贝到迭代器b2处原始内存；b2必须足够大能容纳
7、uninitialized_copy_n(b, n, b2);	从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中
8、uninitialized_fill(b, e, t);		在迭代器(b, e)范围内创建对象，对象的值为t的拷贝
9、uninitialized_fill_n(b, n, t);	从迭代器b指向的位置创建n个对象，b必须能容纳下

										十三、拷贝控制
#类中的五种特殊成员函数：拷贝构造、拷贝赋值、移动构造、移动赋值、析构
这些操作称为拷贝控制操作
1、拷贝构造函数
	1.1 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则此构造函数是
		拷贝构造函数
	1.2 拷贝构造函数通常不应该是explicit的，因为在一些情况下会被隐式地使用
	1.3 合成拷贝构造函数：编译器定义的，但即使我们定义了其他构造函数，编译器也会进行默认合成
	1.4 拷贝 类时只拷贝 类中每个非static成员
	1.5 虽然不能拷贝数组，但合成拷贝构造会逐元素地拷贝一个数组类型的成员
	1.6 拷贝构造函数参数必须是引用类型：如果不是，则调用永远不会成功--为了调用拷贝构造函数，必须拷贝类的参数，
		但为了拷贝实参，又需要调用拷贝构造函数，如此无限循环
	1.7 编译器可以跳过拷贝赋值构造函数，用直接初始化代替
2、拷贝赋值运算符
	2.1 如果未定义，则编译器默认提供
	2.2 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成，也有返回类型和参数列表
		参数表示运算符的运算对象
	2.3 某些运算符必须定义为成员函数，则其左侧对象就绑定到隐式的this参数，右侧对象作为显式参数传入
		通常返回一个指向其左侧运算对象的引用；标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值
		是左侧运算对象的引用
	2.4 合成拷贝赋值运算符：编译器默认提供；返回左侧运算对象的引用
3、析构函数
	3.1 无参数，无返回值，即不能被重载(每个类只有唯一的一个析构函数)
	3.2 构造函数中：成员的初始化是在函数体执行之前完成的，且按照它们在类中的出现顺序进行初始化
	3.3 析构函数中：首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁
	3.4 隐式销毁一个内置指针类型的成员不会delete它所指向的对象，但智能指针有析构，所以会释放所指对象
	3.5 析构函数体自身并不直接销毁成员，成员在析构函数体之后隐含的析构阶段进行销毁的；
		整个销毁过程中，析构函数体作为成员销毁步骤之外的另一部分而进行的

#三/五法则
1、需要析构函数的类也需要拷贝和赋值操作
2、需要拷贝构造的函数一定需要拷贝赋值运算符，反之亦然；但不一定需要析构函数

<C++11> 可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本
		只能对具有合成版本的成员函数使用=default(即，默认构造函数或拷贝控制成员)

#阻止拷贝
1、iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲
<C++11> 2.1 可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝：虽然声明了它们，但是不能使用
			在函数的参数列表后面加上=delete来指出希望将它定义为删除的
		2.2 =delete必须出现在函数第一次声明的时候，可以对任何函数指定=delete，但析构函数不能被删除，如果删除了，
			编译器不允许定义该类型的变量或创建该类的临时对象，但是可以动态分配这种类型的对象，但是不能释放这个对象
		2.3 本质上，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的
		2.4 删除的析构函数会导致合成的默认和拷贝构造函数被定义为删除的
		2.5 对引用进行拷贝时，仅改变指向的对象的值，但不会改变指向的对象
		2.6 当将拷贝控制操作声明为private的时，成员函数和友元中的拷贝操作将会导致链接时错误，所以阻止拷贝的话，
			应该使用=delete而不是声明为private的

#深拷贝浅拷贝
1、浅拷贝
	1.1 编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中
2、深拷贝
	2.1 拷贝指针即可

#交换操作swap
1、如果类定义了自己的swap，那么算法将使用类自定义版本，否则，算法将使用标准库定义的swap
2、一般可以将自定义的swap作为类的友元
3、如果存在类型特定的swap版本，swap调用会与之匹配；如果不存在类型特定的版本，则会使用std中的版本
4、定义swap的类通常用swap来定义它们的赋值运算符，这些运算符使用了名为"拷贝并交换"的技术(将左侧运算对象与右侧的副本交换)

#<C++11> 移动构造函数和std::move()
#include <utility> std::move();
1、通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象，且“移后源”string仍保持一个有效的、可析构的状态
2、string的移动构造函数进行了指针的拷贝，而不是为字符分配内存空间后拷贝字符
3、alloc.construct(dest++, std::move(*elem++));	调用move返回的结果会令construct使用string的移动构造函数
4、移动而非拷贝对象会大幅度提升性能(源地址处资源移动到目的地址处，源地址处资源消失，申请的内存暂且认为自动释放-->line-939)
5、新标准中可以用容器保存不可拷贝的类型，只要它们能被移动即可
6、标准库容器、string和shared_ptr类既支持移动也支持拷贝；IO类和unique_ptr类可以移动但不能拷贝
#右值
<c++11> 为了支持移动操作，新标准引入了一种新的引用类型---右值引用，它有一个重要性质---只能绑定到一个将要销毁的对象
		通过&&来获得右值引用
1、不能将一个右值引用直接绑定到一个左值上，可以将右值引用绑定到要求转换的表达式，字面常量或是返回右值的表达式
2、使用右值引用的代码可以自由地接管所引用地对象的资源
3、不能将一个右值引用绑定到一个右值引用类型的变量上
4、可以显式地将一个左值转换为对应的右值引用类型，通过调用move来获得绑定到左值上的右值引用
	int &&rr1 = 42;
	int &&rr = std::move(rr1);
	调用后不能对移后源对象的值做任何假设；可以销毁一个移后源对象，也可以赋予它一个新值，但不能使用一个移后源对象的值

#移动构造函数和移动赋值运算符
1、移动构造函数
	1.1 第一个参数是该类类型的一个右值引用
	1.2 当编写一个不抛出异常的移动操作时，应该将此事通知标准库；除非标准库中的移动构造函数不会抛出异常，否则它会认为
		移动类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作
		通知方法：<C++11> 构造函数中指明noexcept，出现在参数列表和初始化列表开始的冒号之间
			tip：必须同时在类头文件的声明和定义中都指定noexcept
2、移动赋值运算符
	2.1 返回值为左值引用，参数类型为右值引用
	2.2 移后源对象必须可析构：从一个对象移动数据并不会销毁此对象，因此编写移动操作的时候，必须确保移后源对象进入一个
	可析构状态，可以通过置nullptr来实现
	2.3 移动操作必须保证对象仍然是有效的(指可以安全地为其赋予新值或可以安全地使用而不依赖其当前值)
3、合成的移动操作
	3.1 如果类定义了自己的拷贝操作，编译器就不会合成移动操作，只有类没有定义任何拷贝控制，且类的每个非static数据成员
		都可以移动时，编译器才会为它合成移动操作
	3.2 如果类定义了移动操作，则该类的合成拷贝操作被定义为删除的
	3.3 移动右值，拷贝左值：如果类既有拷贝又有移动，则编译器使用普通函数匹配规则来确定使用哪个构造函数
	3.4 如果没有移动操作，则右值也被拷贝，即使调用std::move();也不会变化

#移动迭代器适配器<C++11>
1、移动迭代器的解引用生成右值引用
2、调用标准库的std::make_move_iterator函数将一个普通迭代器转换为一个移动迭代器(接收一个迭代器，返回移动迭代器)
原迭代器的所有其他操作在移动迭代器中都照常工作，这样内存拷贝时，可以使用移动的方式
3、谨慎使用移动操作，因为移后源对象是未定义的，不能再次访问
4、成员函数可以同时提供拷贝和移动版本：函数接收一个指向const的左值引用，或接受一个指向非const的右值引用
5、当希望从实参"窃取数据"时，通常传递一个右值引用，为了达到目的，实参不能是const的；
类似的，从一个对象进行拷贝的操作不应该改变该对象；
6、为了向后兼容，仍允许右值赋值；但可以在类中阻止，可以强制左侧运算对象是一个左值或右值
在参数列表后放置一个引用限定符&，只能用于非static成员函数，且必须同时出现在函数声明和定义中
对于&限定的函数，只能将它用于左值；&&只能用于右值
7、一个函数可以同时用const和引用限定，但是引用限定符必须跟随在const限定符之后
8、如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符

										十四、重载运算与类型转换
#重载运算符
	1、由关键字operator和其后要定义的运算符号共同组成
	2、除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参
	3、当一个重载的运算符是成员函数时，this绑定到左侧运算对象
	4、对于一个重载运算符来说，它或者是类的成员，或者至少含有一个类类型的参数
	5、当运算符作用于内置类型的运算对象时，无法改变该运算符的含义
	6、可以重载大多数运算符(但不是全部)，只能重载已有的运算符，无权发明新的运算符号；其优先级于对应的内置运算符保持一致
	7、通常不应该重载逗号、取地址、逻辑与和逻辑或运算符
	8、重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容
	9、只有当操作的含义对于用户来说清晰明了时才使用运算符
#可以被重载的运算符："+", "-", "*", "/", "%", "^", "&", "|", "~", "!", ",", "=", "<", ">", "<=", ">=", "++"
	"--", "<<", ">>", "==", "!=", "&&", "||", "+=", "-=", "/=", "%=", "^=", "&=", "|=", "*=", "<<=", ">>="
	"[]", "()", "->", "->*", "new", "new[]", "delete", "delete[]"
#不能被重载的运算符："::", ".*", ".", "?:"

#重载运算符作为成员或非成员的准则
1、赋值、下标、调用和成员访问箭头运算符必须是成员
2、复合赋值运算符一般来说应该是成员，但并非必须
3、改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
4、当把运算符定义为成员函数时，它的左侧对象必须是运算符所属类的一个对象

#重载输出运算符<<
1、第一个形参是一个非常量ostream对象的引用，第二个形参一般来说是一个常量引用，返回它的ostream形参
2、输出运算符尽量减少格式化操作，不应该打印换行符
3、输入输出运算符必须是非成员函数，一般被声明为类的友元

#重载输入运算符>>
1、第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用
2、输入运算符必须处理输入可能失败的情况，而输出运算符不需要

#赋值运算符
1、除了拷贝、引用赋值外，该运算符接收花括号内的元素列表作为参数

#下标运算符
1、一般会定义两个版本，一个返回普通引用，另一个是类的常量成员并且返回常量引用

#递增递减运算符
1、定义递增和递减运算符的类应该同时定义前置版本和后置版本，这些运算符通常应该被定义成类的成员
2、与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用，后置运算符应该返回对象的原值，返回的形式是
一个值而非引用
3、后置版本接收一个额外的(不被使用)int类型的形参，可以使用这个形参，但一般不这么做，只作为区分
4、因为用不到int形参，所以无需为其命名

#成员访问运算符
1、重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象

#函数对象
	1、如果类定义了调用运算符，则该类的对象称作函数对象
	2、lambda是函数对象
	3、lambda表达式产生的类不含默认构造函数、赋值运算符及默认析构函数
	4、lambda有它自己唯一的(未命名)类类型
#标准库函数对象
#include <functional>
plus<Type>  minus<Type>  multiplies<Type>  divides<Type>  modulus<Type>  negate<Type>
equal_to<Type>  not_equal_to<Type>  greater<Type>  greater_equal<Type>  less<Type>  less_equal<Type>
logical_and<Type>  logical_or<Type>  logical_not<Type>
1、标准库规定其函数对象对于指针同样适用

#标准库function类型 <C++11>
#include <functional>
function<T> f;	T表示接受的可调用类型

#类类型转换
1、转换构造函数和类型转换运算符共同定义了类类型转换
2、一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空；类型转换函数通常应该是const

										十五、面向对象程序设计
#继承
	1、类后面加冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符
	2、派生类必须在其内部对所有重新定义的虚函数进行声明
	<C++11> 允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数(在该函数的形参列表之后增加一个override关键字)
#动态绑定：对于不同的派生类参数，根据运行时选择函数的版本
	1、当使用基类的引用或指针调用一个虚函数时将发生动态绑定，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的
		版本，也可能执行某个派生类的版本
	2、作为继承关系中根节点的类通常都会定义一个虚析构函数，即使该函数不执行任何实际操作也是如此
	3、任何构造函数之外的非静态函数都可以是虚函数
	4、C++标准并没有明确规定派生类的对象在内存中如何分布
	5、可以把派生类的对象当成基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上
		这种转换称为"派生类到基类"的类型转换
#继承与构造函数
	1、派生类必须使用基类的构造函数来初始化它的基类部分，基类初始化完派生类中的继承成员后，才进行派生类初始化
    派生类的构造函数将实参传递给基类构造函数，以此进行初始化
	2、可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做，通过调用基类的构造函数来
	初始化那些从基类中继承而来的成员
#继承与静态成员
	1、如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义

#派生类的声明：声明中包含类名但不包含它的派生列表，派生列表以及与定义有关的其他细节必须与类的主体一起出现

#基类的类
1、如果想将某个类用作基类，则该类必须已经定义而非仅仅声明

#防止继承：在类名后跟一个关键字final

#类型转换与继承
  1、理解基类和派生类之间的类型转换是理解C++面向对象编程的关键所在
  2、当使用基类的引用或指针时，实际上并不清楚该引用或指针所绑定对象的真实类型；该对象可能是基类的对象，也可能是派生类
	的对象
  3、和内置指针一样，智能指针类也支持派生类向基类的类型转换
  4、不存在从基类向派生类的隐式类型转换，因为一个基类的对象可能是派生类对象的一部分，也可能不是
  5、编译器在编译时无法确定某个特定的转换在运行时是否安全，因为编译器只能通过检查指针或引用的静态类型来推断
    该转换是否合法
  6、如果在基类中含有一个或多个虚函数，可以使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行
  7、如果已知某个基类向派生类的转换是安全的，则可以使用static_cast来强制覆盖掉编译器的检查工作
  8、派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换
  9、派生类向基类的转换允许我们给基类的拷贝/引用操作传递一个派生类对象(这些操作不是虚函数)
  10、当用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的
    派生类部分将被忽略掉
#静态类型与动态类型
  1、使用继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开
  2、静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型
  3、动态类型则是变量或表达式表示的内存中的对象的对象，直到运行时才可知
  4、基类指针item的静态类型是基类，动态类型依赖于item绑定的实参

#虚函数
  1、必须为每一个虚函数都提供定义
  2、对非虚函数的调用在编译时进行绑定，类似的，通过对象(而不是引用或指针)进行绑定的函数调用也在编译时绑定
    通过指针或引用调用虚函数时，才会在运行时解析该调用
  3、派生类重写的虚函数，可以再一次使用virtual指出该函数性质(但不是必要的)
  4、重写的虚函数必须与基类虚函数一致(例外：类的虚函数返回类型是类本身的指针或引用时，派生类返回其自己的引用或指针
    但是要求从派生类到基类的转换是可访问的)
#<C++11> fina & override
  1、使用override来说明派生类中的虚函数，让编译器为我们发现一些错误
  2、函数定义成的final后，不能被覆盖(成员函数均能被覆盖)
  3、final和override说明符出现在形参列表(包括const和&)以及尾置返回类型之后
#虚函数与默认实参
  1、如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致(如果使用了默认实参，则该实参值由此静态类型决定)
#回避虚函数的机制  
  1、如果希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，使用作用域运算符(编译时完成解析)
  
#抽象基类：含有纯虚函数的类
#纯虚函数
1、在函数体位置书写=0就可以将一个虚函数说明为纯虚函数(=0只能出现在类内部的虚函数声明语句处)
2、也可以为纯虚函数提供定义，不过函数体必须定义在类的外部
3、抽象基类不能创建对象

#派生类构造函数只初始化它的直接基类(也就是直接继承的类)

#访问控制与继承
1、protected：
  1.1 和私有成员类似，受保护的成员对于类的用户来说是不可访问的
  1.2 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的
  1.3 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，派生类对于一个基类对象中的受保护成员
    没有任何访问权限
  1.4 规定：派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊
    的访问权限
2、公有、私有和受保护继承
  2.1 派生访问说明符对于派生类的成员能否访问其直接基类的成员没什么影响(对基类成员的访问权限只与基类中的
    访问权限说明符有关)
  2.2 派生访问说明符的目的是控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限
  2.3 派生访问说明符还可以控制继承自派生类的新类的访问权限
3、派生类向基类转换的可访问性(假定D继承自B)
  3.1 只有当D公有继承B时，"用户代码"才能使用使用派生类向基类的转换，其他均不能使用该转换
  3.2 不论D的继承方式，D的成员函数和友元都能使用派生类向基类的转换
  3.3 如果D继承B的方式是公有或受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，
    如果是私有的，则不能使用
  tip：以能否访问到public和protected成员为标准

#友元与继承
1、友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员

#改变个别成员的可访问性
1、有时需要改变派生类继承的某个名字的访问级别，通过使用using声明可以达到这一目的
2、派生类只能为那些它可以访问的名字提供using声明  using base::mem;

#默认的继承保护级别
1、默认派生运算符也由定义派生类所用的关键字来决定
2、默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的

#继承中的类作用域
1、派生类的作用域嵌套在其基类的作用域之内(如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在
  外层的基类作用域中寻找该名字的定义)

#名字冲突与继承
  2、派生类的成员将隐藏同名的基类成员
#通过作用域运算符来使用隐藏的成员
  1、作用域运算符将覆盖掉原有的查找规则，base::指示编译器从base类作用域开始查找
  2、除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字

#名字查找与继承
1、理解函数调用的解析过程对于理解C++的继承至关重要
2、名字查找先于类型检查
3、声明在内层作用域的函数并不会重载声明在外层作用域的函数；因此，定义派生类中的函数也不会重载其基类中
  的成员，会覆盖，即使派生类成员和基类成员的形参列表不一致，基类成员也会被覆盖掉；覆盖掉后，调用派生类
  如果调用错误，会直接报错，不会检查基类成员

#虚函数与作用域
1、所以重写虚函数如果不一致，则无法通过基类指针或引用调用派生类的虚函数了

#覆盖重载的函数
1、成员函数无论是否是虚函数都能被重载
2、如果派生类想覆盖派生类的所有版本的重载函数，可以为重载的成员提供一条using语句，这样就无需全部覆盖一遍了
3、using声明语句指定一个名字而不指定形参列表，此时派生类只需定义其特有的函数就可以了
4、基类函数的每个实例在派生类中都必须是可访问的

#构造函数和拷贝控制
#虚析构函数
  1、通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本
  2、虚析构函数也会被继承
  3、如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为
  4、虚析构函数将阻止合成移动操作
#合成拷贝控制与继承
  1、合成的成员，负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作
  2、无论基类成员是合成的版本还是自定义的版本都没有太大影响，唯一要求是相应的成员应该可访问，并且不是一个
    被删除的函数
  3、对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类，以此类推直至
    继承链的顶端
#移动操作与继承
  1、大多数基类都会定义一个虚析构函数
  2、因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先
    在基类中进行定义，派生类也会相应的获得合成的移动操作(不含有排斥移动的成员)
#定义派生类的拷贝或移动构造函数
  1、默认情况下，基类的默认构造函数初始化对象的基类部分
  2、要想使用基类拷贝或移动构造函数，必须在派生类构造函数初始值列表中显式调用该构造函数
    D(const D &d) : Base(d) {/* ... */}
    D(D &&d) : Base(std::move(d)) {/* ... */}
#派生类赋值运算符
  1、派生类的赋值运算符也必须显式的为其基类部分赋值
#派生类析构函数
  1、对象的基类部分也是隐式销毁的
  2、派生类析构函数只负责销毁由派生类自己分配的资源
  3、派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后
#在构造函数和析构函数中调用虚函数
  1、派生类对象的基类部分将首先被构建，当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态
  2、销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了
  3、如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本

#继承的构造函数
  <C++11> 派生类能够重用其直接基类定义的构造函数，这些构造函数并非以常规的方式继承而来
    1、一个类只初始化它的直接基类，也只能继承其直接基类的构造函数
    2、类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们
    3、using Base::Base;
    4、using声明语句将令编译器产生代码，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同
      的构造函数derived(parms) : base(args) (也等价于继承的构造函数)
    5、一个构造函数的using声明不会改变该构造函数的访问级别
    6、一个using语句不能指定explicit或constexpr；如果基类有这两种属性，则继承的构造函数也拥有相同的属性
#继承的构造函数的特点
  1、当一个基类构造函数含有默认实参时，这些实参并不会被继承；相反，派生类将获得多个继承的构造函数，其中
    每个构造函数分别省略掉一个含有默认实参的形参
  2、如果基类含有几个构造函数，除了两种例外，大多数派生类会继承所有这些构造函数
    2.1 例外一：派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本；如果派生类定义的构造函数和
      基类的具有相同的参数列表，则该构造函数将不会被继承；定义在派生类中的构造将替换继承的构造
    2.2 例外二：继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，
      则它也将拥有一个合成的默认构造函数

#容器与继承
#在容器中放置(智能)指针而非对象
  1、当我们希望在容器中存放具有继承关系的对象时，实际上存放的通常是基类的(智能)指针

                      十六、模板与泛型编程
#定义模板
  1、template <typename(class) T1, typename T2, ... , typename Tn>
  2、实际类型在编译时确定
  3、模板定义中，模板参数列表不能为空
  4、typename是在模板已经广泛使用之后在引入C++语言的

#函数模板
#非类型模板参数
  1、可以在模板中定义非类型参数
  2、一个非类型参数表示一个值而非一个类型，通过一个特定的类型名来指定非类型参数而非关键字
  3、一个非类型参数可以是整型，或者是一个指向对象或函数类型的指针或(左值)引用
  4、绑定到非类型整型参数的实参必须是一个常量表达式，绑定到指针或引用非类型参数的实参必须具有静态的生存期
#inline和constexpr的函数模板
  1、函数模板可以声明为inline或constexpr的，如同非模板函数一样
  2、inline或constexpr说明符放在模板参数列表之后，返回类型之前
#编写类型无关的代码
  1、模板程序应该尽量减少对实参类型的要求
  2、编写泛型编程代码的两个重要原则：
    2.1 模板中的函数参数是const的引用
    2.2 函数体中的条件判断仅使用<比较运算
#模板编译
  1、当使用模板时，编译器才生成代码
  2、为了生成实例化版本，编译器需要掌握函数模板或类模板成员函数的定义
  3、函数模板和类模板成员函数的定义通常放在头文件中
  4、必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的
  5、用来实例化模板的所有函数、类型以及类型关联的运算符的声明都必须是可见的
  6、大多数编译错误在实例化期间报告(可能在链接时才报告)
  7、保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作

#类模板
  1、编译器不能为类模板推断模板参数类型，需要在尖括号后提供额外信息
  2、一个类模板的每个实例都形成一个独立的类；类型Blob<string>与任何其他Blob类型都没有关联，
    也不会对任何其他Blob类型的成员有特殊访问权限
  3、在模板作用域中引用模板类型：通常将模板自己的参数当作被使用模板的实参
  4、定义在类模板之外的成员函数就必须以关键字template开始，后接类模板参数列表
    template <typename T>
    ret-type Blob<T>::member-name(parm-list)
  5、默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化
  6、当使用一个类模板类型时必须提供模板实参，但这一规则有一个例外：在类模板自己的作用域中，可以
    直接使用模板名而不提供实参
  7、在一个类模板的作用域内，可以直接使用模板名而不必指定模板实参
#类模板与友元
  1、一对一友好关系：
    1.1 模板声明：
      template <typename> class BlobPtr;
      template <typename> class Blob
    1.2 友元实现：
      template <typename T> class Blob {
          friend class BlobPtr<T>;
      };
  2、通用和特定的模板友好关系
    2.1 一个类可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元
    2.2 给模板指定实参即可限定特定的实例
    2.3 为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数
    <C++11> 可以将模板类型参数声明为友元：
      template <typename Type> class Bar {
          friend Type;
      };
  3、可以定义一个typedef来引用实例化的类，不能定义一个typedef引用一个模板
  <C++11> 允许为类模板定义一个类型别名：template <typename T> using twin = pair<T, T>;
  4、定义一个模板类型别名时，可以固定一个或多个模板参数

#类模板的static成员
  1、每个实例都有自己的static成员实例，所有Foo<x> 类型对象共享相同的static对象
  2、为static数据成员也定义为模板：template <typename T> size_t Foo<T>::ctr = 0;
  3、可以用类名直接访问static成员，但必须指定模板实参
  4、static成员只有在使用时才会实例化

#模板参数
#模板参数作用域
  1、模板内不能重用模板参数名，所以一个模板参数名在一个特定模板参数列表中只能出现一次
  2、正常的名字隐藏规则决定了T的typedef 被类型参数T隐藏：
    typedef double T;
    template <typename T> void f(T t) {
        T temp = a; //是模板参数类型T，不是double
    }
#模板声明
  1、声明必须包含模板参数，声明模板类可以不加模板参数
#使用类的类型成员
  1、默认情况下，C++语言假定通过作用域运算符访问的名字不是类型，如果希望使用一个模板类型
    参数的类型成员，就必须显式告诉编译器该名字是一个类型，通过使用关键字typename来实现(而不是class)
  2、typename T::mem表示类型，T::mem表示静态成员
#默认模板实参
  <C++11> 可以为函数和类模板提供默认实参(早期只允许为类模板提供默认实参)
    template <typename T, typename F = less<T>>
  1、与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参
  2、如果一个类模板为其所有模板参数都提供了默认参数，且我们希望使用这些默认实参，就必须在模板名之后
    跟一个空尖括号对

#成员模板
  1、一个类可以包含本身是模板的成员函数，这种成员被称为成员模板；成员模板不能是虚函数
#类模板的成员模板
  1、类和成员各自有自己的、独立的模板参数
  2、当在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表；
    类模板参数列表在前，后跟成员自己的模板参数列表
#实例化与成员模板
  1、在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参
  2、编译器通常根据传递给成员模板的函数实参来推断它的模板实参

#控制实例化
  1、当模板被使用时才会实例化意味着相同的实例可能出现在多个对象文件中；
  2、大系统中，在多个文件中实例化相同模板的额外开销会非常严重；
  <C++11> 可以通过显式实例化来避免这种开销：
    extern template declaration;  // 实例化声明
    template declaration;         // 实例化定义
    declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参
  3、对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义
  4、对于每一个实例化声明，在程序中某个位置必须有其显式的实例化定义
  5、一个类模板的实例化定义会实例化该模板所有成员，包括成员函数，因此用来显式实例化的一个类模板
    的类型，必须能用于模板的所有成员

#模板实参推断
  1、实参传递给模板形参时，通常不对实参类型转换，而是生成一个新的模板类型
  2、类型转换中，能在调用中应用于函数模板的包括如下两相：
    2.1 const转换：可以将一个非const对象的引用或指针传递给一个const的形参
    2.2 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换
  3、其他类型转换：算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于模板
  4、如果函数参数类型不是模板参数，则对实参进行正常的类型转换

#函数模板显式实参
  1、显式模板实参在尖括号中给出，位于函数名之后，实参列表之前：sum<long long> (10, 10);
  2、对于模板参数类型已经显式指定了函数实参，也进行正常的类型转换
  3、尾置返回出现在参数列表之后，它可以使用函数的参数decltype(*beg);
  4、如果想让函数返回值而不是引用，使用库模板typename std::remove_reference<>::type;  (#include type_traits)
    如果T是一个指针类型，则std::remove_reference<T>::type是T指向的类型

#函数指针指向函数模板
  1、如果有重载的指针，则想要没有歧义调用函数模板，必须指定显式实参

#模板实参推断和引用
  1、template <typename T> void f(T &p);
    传给T的如果是const的，则T将被推断为const类型(非引用类型)

#引用折叠和右值引用参数
  1、通常不能将一个右值引用绑定到一个左值上，但C++定义了两个例外规则：
    template <typename T> void f(T&&);
    1.1 当将一个左值传递给函数的右值引用参数，且此右值引用指向(T&&)时，编译器推断T
      为实参的左值引用类型
    1.2 如果间接创建了一个引用的引用，则这些引用形成了"折叠"
      1.2.1 所有情况下(除了1.1)，引用会折叠成一个普通的左值引用类型
      <C++11> 右值引用的右值引用会折叠成右值引用
    1.3 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数
    1.4 可以将任何类型实参传递给T&&类型的函数参数
  2、虽然不能隐式地将一个左值转换为右值引用，但可以用static_cast显式的将一个左值转换为一个右值引用

#转发
  1、模板函数中调用函数，传递参数
  2、通过将模板函数参数定义为T&&，它对应的实参的const属性和左值/右值属性将得到保持
    template <typename F, typename T1, typename T2>
    void flip(F f, T1 &&t1, T2 &&t2) { f(t2, t1); }
  3、调用中使用std::forward保持类型信息
    3.1 #include <utility>
    3.2 用于指向T&&时，forward会保持原始参数类型
    3.3 forward必须通过显式模板实参来调用
    3.4 forwardT>的返回类型是T&&

#重载与模板
  1、函数模板可以被另一个模板或普通函数重载
  2、调用规则：(如果多个函数提供同样好的匹配)
    2.1 如果同样好的函数中只有一个是非模板函数，则选择此函数
    2.2 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板
    2.3 否则此调用有歧义
  3、当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本
    f(const string*) -> f(const T*)最特例化
    f(const string*&) -> f(const T&)更通用
  4、定义任何函数之前，记得声明所有重载的函数版本

#可变参数模板
  1、可变数目的参数叫参数包
  2、class...或typename...指出
#sizeof...运算符
  1、返回一个常量表达式
  template<typename ... Args> void g(Args ... args) { cout << sizeof...(Args) << endl; }
#包扩展
  1、当扩展一个包时，需要提供用于每个扩展元素的模式：
    1.1 template <typename T, typename ... Args>
        ostream &print(ostream &os, const T &t, const Args&... rest)  //扩展Args
        {
            os << t << ",";
            return print(os, rest...);  //扩展rest
        }
    1.2 对Args扩展中，编译器将模式const Args&应用到模板参数包Args中的每个元素；
        因此，此模式扩展结果是：一个逗号分隔的零个或多个类型的列表，每个类型都形如const type&
    1.3 return print(os, debug_rep(rest)...);
        表示对函数参数包rest中的每个元素调用debug_rep，扩展结果就是一个逗号分隔的debug_rep调用列表
#转发包
  <C++11> 允许组合使用可变参数模板与forward机制来编写函数，实现将其实参不变的传递给其他函数
  template<typename... Args>
  void fun(Args&&... args) {
      work(std::forward<Args>(args)...);
  }

#模板特例化
  1、模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型
  2、特例化函数模板
    template <> int compare(const char* const &p1, const char* const &p2);
    特例化template <typename T> int compare(const T&, const T&);
    二者类型必须匹配
  3、一个特例化版本本质上是一个实例，而非函数名的一个重载版本，所以不影响函数匹配
  4、注意对于特例化的声明，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码；不易找错
  5、特例化类模板
    5.1 打开std命名空间，向命名空间添加成员：namespace std {} 
    花括号对之间的任何定义都将成为命名空间std的一部分
  6、类模板部分特例化
    6.1 一个类模板的部分特例化本身是一个模板
    6.2 使用它的用户还必须为那些在特例化版本中未指定的模板参数提供实参
    6.3 特例化类的成员而不是类
    template <class T> struct remove_reference { typedef T type; }    //原始
    template <class T> struct remove_reference<T&> { typedef T type; }  //左值引用
    template <class T> struct remove_reference<T&&> { typedef T type; } //右值引用

                                十七、标准库特殊设施
#tuple类型
  操作：
    tuple<T1, T2, ... , Tn> t;                    所有成员都进行值初始化
    tuple<T1, T2, ... , Tn> t(v1, v2, ... , vn);  对应值初始化，构造函数是explicit的
    make_tuple(v1, v2, ... , vn);                 返回一个用给定初始值初始化的tuple
    t1 == t2  t1 != t2
    t1 relop t2                                   tuple的关系运算使用字典序，两个tuple必须具有相同数量的成员
                                                  使用<比较二者对应成员
    get<i> (t)                                    返回t的第i个数据成员的引用，tuple所有成员都是public的
    tuple_size<tupleType>::value                  表示tuple类型中成员的数量，tuple类型初始化
    tuple_element<i, tupleType>::type             通过整型和tuple类型初始化，表示tuple类型中指定成员的类型
#可以将tuple序列传递给算法，并且可以在无序容器中将tuple作为关键字类型

#bitset类型
  #include <bitset>
  使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合
  
  构造函数：
    bitset<n> b;                                  b有n位，均为0，构造函数是constexpr的
    bitset<n> b(u);                               b是unsigned long long值u的低n位拷贝，constexpr
    bitset<n> b(s, pos, m, zero, one);            b是string s从pos开始m个字符拷贝，s只能包含zero或one，如果包含
                                                  其他元素会报错，s在b中用01保存，pos默认0，m默认string::npos，
                                                  zero默认'0', one默认'1'
    bitset<n> b(cp, pos, m, zero, one);           cp是字符数组，如果未提供m，cp必须指向一个c风格字符串；
                                                  如果提供了字符串，则从cp开始必须至少有m个zero或one字符
    1、当用整型值来初始化bitset时，此值将被转化为unsigned long long类型并被当作位模式来处理
    2、当用字符串来初始化bitset时，此值中的01直接表示位模式("1001")
    3、string中下标最大的字符用来初始化bitset中的低位
  操作：
    b.any();                                      b中是否存在置位的二进制位
    b.all();                                      b中所有位都置为了吗
    b.none();                                     b中不存在置位的二进制位吗
    b.count();                                    b中置位的位数
    b.size();                                     一个constexpr函数，返回b中的位数
    b.test(pos);                                  若pos位置的位是职位的，则返回true，否则false
    b.set(pos, v);                                将位置pos处的位设置为bool值v，v默认true
    b.set();                                      如果未传实参，则将b中所有位置位
    b.reset(pos);                                 将位置pos处的位复位或将b中所有位复位
    b.reset();
    b.flip(pos);                                  改变位置pos处的位的状态或每一位状态
    b.flip();
    b[pos];                                       访问pos处的位；如果b是const的，则返回true
    b.to_ulong();                                 返回一个unsigned long或一个unsigned long long值，位模式与b相同
    b.to_ullong();                                
    b.to_string(zero, one);                       返回一个string，b中的位模式
    os << b;                                      将b中二进制位打印为字符1或0，打印到流os
    is >> b;                                      从is读取字符存入b，当下一位不是0或1，或已经读入b.size()个位时
                                                  读取过程停止
    1、置位：置为1

#正则表达式(regular expression)
  #include <regex>
  regex库组件
    regex                                         表示有一个正则表达式的类(比较全部)
    regex_match                                   将一个字符序列与一个正则表达式匹配(比较子串)
    regex_search                                  寻找第一个与正则表达式匹配的子序列
    regex_replace                                 使用给定格式替换一个正则表达式
    sregex_iterator                               迭代器适配器，调用regex_search来遍历一个string中所有匹配的子串
    smatch                                        容器类，保存在string中搜索的结果
    ssub_match                                    string中匹配的子表达式的结果
  1、regex_search和regex_match的参数
    (seq, m, r, mft)                              在字符序列seq中查找regex对象r中的正则表达式；seq可以是一个string、
    (seq, r, mft)                                              表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针
                                                  m是一个match对象，保存匹配结果的相关细节；m和seq必须具有兼容的类型
                                                  mft是一个可选的regex_constants::match_flag_type值
  2、regex使用的正则表达式语言是ECMAScript，[[::alpha:]]匹配任意字母，+和*分别表示"一个或多个"或"零个或多个"匹配
#指定regex对象的选项
  *regex(和wregex)选项
    regex r(re);                                  re表示一个正则表达式，可以是string、字符范围迭代器对、指向空
    regex r(re, f);                               字符结尾的字符数组的指针、一个字符指针和一个计数器或一个花括号
                                                  包围的字符列表；f是指出对象如何处理的标志，默认ECMA
    r1 = re;                                      将r1中的正则替换为re
    r1.assign(re, f);                             与赋值运算符"="等价
    r.mark_count();                               r中子表达式的数目
    r.flags();                                    返回r的标志集
  *定义regex时指定的标志
    定义在regex和regex_constants::syntax_option_type中
    icase                                         在匹配时忽略大小写
    nosubs                                        不保存匹配的子表达式
    optimize                                      执行速度优先于构造速度
    ECMAScript                                    使用ECMA-262指定的语法
    basic                                         使用POSIX基本的正则表达式语法
    extended                                      使用POSIX扩展的正则表达式语法
    awk                                           使用POSIX版本的awk语言的语法
    grep                                          使用POSIX版本的grep语法
    egrep                                         使用POSIX版本的egrep语法
  1、最后6个标志指出编写正则表达式所用的语言，这6个必须设置一个，也只能设置一个，默认ECMAScript(浏览器使用的regex语言)
  2、正则表达式的语法正确性是在运行时解析的
  3、正则表达式的编译是一个非常慢的操作，因此，构造一个regex对象以及向一个已存在的regex赋予一个新的正则表达式
  可能是非常耗时的；所以，尽量避免创建很多不必要的regex
  *如果输入序列类型                               则使用正则表达式类
   string                                         regex、smatch、ssub_match、sregex_iterator
   const char*                                    regex、cmatch、csub_match、cregex_iterator
   wstring                                        wregex、wsmatch、wssub_match、wsregex_iterator
   const wchar_t*                                 wregex、wcmatch、wcsub_match、wcregex_iterator
#迭代器适配器操作
  sregex_iterator it(b, e, r);                    遍历迭代器b和e表示的string；调用sregex_search(b, e, r)将it
                                                  定位到输入中第一个匹配位置
  sregex_iterator end;                            尾后迭代器
  *it、it->                                       返回一个smatch对象的引用或一个指向smatch对象的指针
  it++、++it                                      调用regex_search在输入string中查找下一个匹配
  it1 == it2、it1 != it2                          非尾后，相同输入序列和regex对象构造，则相等；尾后直接相等

#smatch操作
  m.ready();                                      如果设置了m，返回true；如果返回false，则对m进行操作是未定义的
  m.size();                                       匹配失败，返回0；否则返回最近一次匹配的regex中子表达式的数目
  m.empty();                                      若m.size() == 0返回true
  m.prefix();                                     一个ssub_match对象，表示当前匹配之前的序列
  m.suffix();                                     一个ssub_match对象，表示当前匹配之后的部分
  m.format(...);                                  替换操作
  m.length(n);                                    第n个匹配的子表达式的大小，n = 0表示整个匹配
  m.position(n);                                  第n个子表达式距序列开始的距离
  m.str(n);                                       第n个表达式匹配的string
  m[n];                                           对应第n个子表达式的ssub_match对象
  m.begin(), m.end();                             表示m中sub_match元素范围的迭代器
  m.cbegin(), m.cend();

#随机数
  1、C++程序不应该使用库函数rand，而应使用default_random_engine类和恰当的分布类对象
  2、定义在头文件random中的随机数库通过一组协作的类来解决非均匀分布、浮点数的问题：随机数引擎、随机数分布类
#随即数引擎
  1、是函数对象类，定义了调用运算符，不接受参数并返回一个随机unsigned整数
#随机数引擎操作
  Engine e;                                       默认构造函数；使用该引擎类型默认的种子
  Engine e(s);                                    使用整型值s作为种子
  e.seed(s);                                      使用种子s重置引擎状态
  e.min();                                        此引擎可生成的最小值和最大值
  e.max();
  Enginne::result_type                            此引擎生成的unsigned整型类型
  e.discard(u);                                   将引擎推进u步；u的类型为unsigned long long

#随机数发生器：分布对象和引擎对象的组合
  1、一个给定的随机数发生器一直会生成相同的随机数序列
  2、设置种子就不会产生相同序列了

#IO库再探
  1、格式化输入输出
    1.1 改变bool值格式：boolalpha、noboolalpha
    1.2 进制：hex、oct、dec(浮点数不受影响，仅改变整型)
    1.3 显示进制：showbase
    1.4 转换大写：uppercase
    1.5 浮点数精度：precision、setprecision   #include <iomanip>
  2、未格式化输入输出
    is.get(ch);                                   从istream is读取下一个字节存入字符ch中，返回is
    os.put(ch);                                   将字符ch输出到ostream os，返回os
    is.get();                                     将is的下一个字节作为int返回
    is.putback(ch);                               将字符ch放回is，返回is
    is.unget();                                   将is向后移动一个字节，返回is
    is.peek();                                    将下一个字节作为int返回，但不从流中删除它
1、由于istream和ostream类型通常不支持随即访问，只适用于fstream和sstream

                          十八、用于大型程序的工具
#异常处理
  1、throw一个异常后会在catch中寻找，如果栈展开没有找到，则程序将调用标准库函数terminate
  2、栈展开过程中，局部对象会被自动销毁
  3、catch会执行第一个匹配的，且绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常类型和catch
    声明的类型是精确匹配的(const转换，基类派生类转换，数组-指针，函数-指针)
  4、空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内；如果在处理代码之外的区域遇到了
    空throw语句，编译器将调用terminate
#捕获所有异常的处理代码
  1、catch(...)通常与重新抛出语句一起使用
#函数try语句块
  1、构造函数初始化时抛出异常，但函数体内的catch无法捕获；引入函数try
  2、既能处理构造函数体或析构函数体，也能处理构造函数的初始化过程或析构函数的析构过程
    template <typename T>
    Blob<T>::Blob(std::initializer_list<T> il) try : data(std::make_shared<std::vector<T>>(il)) {}
    catch(const std::bad_alloc &e) { handle_out_of_memory(e) }
    catch既可以捕获函数体也可以捕获初始化
#<C++11> noexcept
  1、关键字noexcept跟在函数的参数列表后面，用以标志该函数不会抛出异常
  2、noexcept说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现
  3、应该在尾置返回类型之前
  4、也可以在函数指针的声明和定义中指定noexcept
  5、在typedef或类型别名中则不能出现noexcept
  6、在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数 = 0之前
  7、编译器不会在编译时检查noexcept说明，所以在noexcept函数中throw，程序会调用terminate；
    上述过程对是否执行栈展开未作约定
  8、noexcept(true)不会抛出异常，false可能会抛出异常
  9、noexcept()运算符，返回bool右值常量表达式，表示给定的表达式是否会抛出异常；
    与sizeof类似，noexcept也不会求其运算对象的值
  10、函数指针及该指针所指函数必须具有一致的异常说明
  11、如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；如果基类允许，则派生
    可有可无抛出
  12、如果定义的析构函数没有提供异常说明，则编译器将合成一个；合成的异常说明将与假设由编译器为类合成析构
    函数时所得的异常说明一致
#异常体系
  1、实际的应用程序通常会自定义except的派生类以扩展其继承体系

#命名空间
  1、通过在某个命名空间中定义库的名字，可以避免全局名字固有的限制
  2、定义：namespace name { ... }
  3、命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部
  4、命名空间可以是不连续的，也就是可以多次打开命名空间
  5、#include应该出现在打开命名空间的操作之前
  6、在本命名空间外部定义时，不能在其他命名空间中定义
  7、全局作用域：   ::member_name;
  8、内层命名空间声明的名字将隐藏外层命名空间声明的同名成员
#内联命名空间
  1、外层命名空间可以直接使用而不需要加前缀，通过外层命名空间的名字即可访问
  2、关键字inline必须出现在命名空间第一次定义的地方，后续再打开命名空间可写可不写
  3、用处：更新版本的时候，可以将旧版本声明为一般内嵌命名空间，而新版本可以声明为内联命名空间
#未命名空间
  1、定义：nameplace {}
  2、空间中定义的变量具有静态生命周期
  3、和其他命名空间不同，未命名的命名空间仅在特定文件内部有效，其作用域不会跨越多个不同的文件
  4、不能对未命名的命名空间的成员使用作用域运算符
  5、未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同
  6、未命名空间一定要与全局作用域有所区别，不然会有二义性
#命名空间类型别名
  1、nameplace def = std;
  2、不能在命名空间还没有定义前就声明别名
  3、也可以指向一个嵌套的命名空间
#using声明
  1、一条using声明语句一次只引入命名空间的一个成员
  2、一条using声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中；
  在类的作用域中，这样的声明语句只能指向基类成员
#using指示
  1、using指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中
  2、通常情况下，命名空间中会含有一些不能出现在局部作用域中的定义，因此，using指示一般被看作是
    出现在最近的外层作用域中
#实参相关的查找与类类型形参
  1、当给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间，对于
    传递类的引用或指针的调用同样有效
  2、一个另外的未声明的类或函数如果第一次出现在友元声明中，则认为它是最近的外层命名空间的成员
  3、如果using声明所在作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该using声明将引发错误
  4、using指示不会产生错误，只要指明命名空间即可

#多重继承
  1、构造一个派生类的对象将同时构造并初始化它的所有基类子对象，只能初始化直接基类
  2、基类的构造顺序与派生列表中的基类的出现顺序保持一致
  3、如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本
  4、可以令某个可访问基类的指针或引用直接指向一个派生类对象，编译器不会在派生类向基类的几种转换中
    进行比较和选择，因为在它看来转换到任意一种基类都一样好
  5、两个同级基类作为形参时，传入不带前缀限定符的派生类会产生编译错误
  6、对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时
    必须明确指出它的版本Base::
    6.1 即使派生类继承的两个函数形参列表不同也可能发生错误
    6.2 即使成员在一个类中是私有的，而在另一个类中是公有的或受保护的，同样也可能发生错误
#虚继承
  1、如果间接继承一个基类两次，则会产生两份拷贝，共享行为无法实现；通过虚继承解决这个问题
  2、虚继承：令某个类做出声明，承诺愿意共享它的基类
  3、共享的基类子对象称为虚基类
  4、不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象
  5、指定虚基类的方式是：在派生列表中添加关键字virtual----class derived : public virtual base { /* ... */}
  6、不论是基类还是虚基类，派生类对象都能被可访问基类的指针或引用操作
  7、在虚派生中，虚基类是由最低层的派生类初始化的
  8、虚基类总是先于非虚基类构造，与它们在继承体系中的次序与位置无关

                                  十九、特殊工具与技术
#控制内存分配
  1、编译器将使用自定义的版本替换标准库定义的版本(operator new、operator delete)
  2、operator new函数或者operator new[]函数来说，它的返回类型必须是void*，第一个形参类型必须是size_t且
    该形参不能含有默认实参
  3、void *operator new(size_t, void*);这种形式只供标准库使用，不能被用户重新定义
  4、operator delete或operator delete[]函数来说，它们的返回类型必须是void，第一个形参的类型必须是void*
  5、这两个函数并没有重载new和delete，目的在于改变内存分配的方式
  6、new执行过程：先调用operator new函数以获取内存空间，然后在得到的内存空间中构造对象
  7、delete执行过程：先销毁对象，然后调用operator delete函数释放对象所占空间
#定位new
  1、早期没有allocator类，就用operator new和operator delete来代替allocate和deallocate来负责分配或释放空间
    但没有construct构造对象，但是可以使用定位new来构造
  2、new (place_address) type
     new (place_address) type (initializers)
     new (place_address) type [size]
     new (place_address) type [size] { braced initializer list }
     place_address必须是一个指针，初始值列表将用于构造新分配的对象
  3、定位new允许在一个特定的、预先分配的内存地址上构造对象
  4、当只传入一个指针类型的实参时，定位new表达式构造对象但不分配内存
  5、定位new与conostruct区别：前者传入的指针不需要指向operator new分配的内存，后者指针必须指向同一个allocator
    对象分配的内存(传给定位new的指针甚至不需要指向动态内存)

#运行时类型识别RTTI
  1、此功能由两个运算符实现：
    1.1 typeid运算符，用于返回表达式的类型
    1.2 dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用
  2、适用情况：想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数
  3、使用时必须加倍小心，必须清楚知道转换的目标类型并且必须家逆差类型转换是否被成功执行
#dynamic_cast运算符
    dynamic_cast<type*>(e);   e必须是有效的指针
    dynamic_cast<type&>(e);   e必须是一个左值
    dynamic_cast<type&&>(e);  e不能是左值
    type必须是类类型，通常应该有虚函数
    e的类型必须满足三条之一：type的公有派生类、type的公有基类、type类型
  1、如果dynamic_cast转换目标是指针且失败了，则返回0；引用失败，抛出bad_cast异常(typeinfo头文件)
  2、可以对nullptr执行dynamic_cast
#typeid运算符
  1、可以获得表达式类型   typeid(e);
  2、操作结果是常量对象的引用，对象类型是标准库类型type_info或type_info的公有派生类型(typeinfo头文件)
  3、可以用作于任意类型表达式，顶层const被忽略
  4、作用于数组或函数时，不会转换为指针
  5、没有虚函数的类，返回其静态类型；有的话，运行时才求得
  6、当typeid作用于指针时(而非指针所指的对象)，返回的结果是该指针的静态编译时类型
  操作：
    1、t1 == t2
    2、t1 ！= t2
    3、t.name();
    4、t1.before(t2);

#枚举类型
  1、限定作用域：enum class(enum struct) name {};   作用域外不可访问，可以加作用域限定符
  2、不限定作用域：enum (name) {};
  3、默认，枚举值从0开始，依次加1；也可以指定专门的值，值不一定唯一
  4、每个枚举成员本身就是一条常量表达式
  5、必须使用enum类型的一个枚举成员或该类型的另一个对象来进行初始化或赋值
  6、不限定作用域的枚举类型的对象或枚举成员自动转换成整型
  <C++11> 可以在enum名字后加上冒号以及我们想在该enum中使用的类型：enum value : unsigned long long {};
          默认是int，不限定作用域不存在默认类型
  7、enum的前置声明必须指定其成员的大小

#类成员指针
  1、数据成员指针
    1.1 const std::string classname::*pdata;    指向classname对象的string成员
    1.2 只能读取内容，但不能写入内容
    1.3 初始化时，需指定它所指的成员，但未指定对象，解引用时才提供对象信息
    1.4 访问运算符 .*和->*
    1.5 指针指向的是成员而非实际数据，要想使用指针，必须绑定到类类型对象上
  2、成员函数指针
    2.1 指向成员函数的指针也需要指定目标函数的返回类型和形参列表
    2.2 如果成员函数是const成员或者引用成员，则必须将const限定符或&限定符包含进来
    2.3 定义：char (class::*pmf)(class::pos, class::pos) const;
    2.4 成员函数和指向该成员的指针之间不存在自动类型转换规则：pt = &func  pt = func(错误)

#嵌套类
  1、外层类的对象和嵌套类的对象是互相独立的
  2、嵌套类的对象中不包含任何外层类定义的成员，外层类的对象也不包含任何嵌套类定义的成员
  3、外层类对嵌套类的成员没有任何特殊的访问权限，反过来同理

#union联合
  1、一个unoin可以有多个数据成员，但在任意时刻只有一个数据成员可以有值
  2、当给union的某个成员赋值后，其他成员就变成未定义的状态了
  3、union不能含有引用成员
  <C++11> 含有构造函数或析构函数的类类型也可以作为union的成员类型，union可以为其指定访问权限；默认
    union是public
  4、union也可以定义包括构造函数和析构函数在内的成员函数，在union中不能含有虚函数
  5、初始化的值用于第一个成员，花括号包围
#匿名union
  1、匿名union的定义所在的作用域内该union的成员都是可以直接访问的
  2、匿名union不能包含受保护的成员或私有成员，也不能定义成员函数

#局部类
  1、类定义在某个函数内部
  2、局部类的所有成员都必须完整定义在类的内部
  3、不允许声明静态数据成员
  4、局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员
  5、局部类不能使用函数作用域中的变量

#不可移植的特性
  1、位域
    1.1 当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域
    1.2 类可以将其(非静态)数据成员定义成位域，在一个位域中含有一定数量的二进制位
    1.3 位域在内存中的布局是与机器相关的
    1.4 位域的类型必须是整型或枚举类型，带符号位域的行为是由具体实现确定的，所以通常情况下使用
      无符号类型保存一个位域
    1.5 unsigned int mode: 2; 该表达式用于指定成员所占的二进制位数
    1.6 在类的内部连续定义的位域压缩在同一整数的相邻位，从而提供存储压缩
    1.7 取地址&不能用于位域，任何指针不能指向类的位域
  2、volatile限定符
    2.1 程序可能包含一个由系统时钟定时更新的变量，当对象的值可能在程序控制或检测之外被改变时，
      应将该对象声明为volatile，告诉编译器不应对这样的对象进行优化
    2.2 只有volatile的成员函数才能被volatile对象调用
    2.3 合成的拷贝对volatile对象无效
  3、链接指示：extern "C"
    3.1 要想把C++代码和其他语言编写的代码放在一起使用，要求必须有权访问该语言的编译器，并且这个
      编译器与当前的C++编译器是兼容的
    3.2 链接指示不能出现在类定义或函数定义的内部，同样的链接指示必须在函数的每个声明中都出现
      extern "C" size_t strlen(conost char*);
      extern "C" { /* ... */}
      也可以用于整个头文件
    3.3 链接指示可以嵌套
    3.4 C函数指针与C++函数指针之间不能进行赋值操作
    3.5 链接指示对整个声明都有效，如果希望给C++函数传入一个指向C函数的指针，则必须使用类型别名
    3.6 导出C++函数到其他语言：extern "C" double calc () { /* ... */}，编译器将为该函数生成适合
      于指定语言的代码(共享有限制)
    3.7 有时需要在C和C++中编译同一个源文件，在编译C++版本的程序时，预处理器定义了__cplusplus
      利用这个变量，可以在编译C++程序时有条件地包含进来一些代码
