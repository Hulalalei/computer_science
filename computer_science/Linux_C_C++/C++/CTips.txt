===========================================C===============================================
									c语言预备知识
#先规划再敲代码，记得写注释

#c在提供高级语言便利的同时，还能在为汇编语言所保留的级别上工作，这使其成为编写设备驱动程序和嵌入式代码的首选语言

#c是在美国用标准美式键盘开发的语言

#开发unix系统时，设计了c语言；c语言具有通常是汇编语言才具有的微调控制能力，可以获得最大运行速度或最
有效的使用内存，c语言可以访问硬件、操控内存中的位

#c语言可移植性较好，但程序中针对特殊硬件设备(如：显示监视器)或操作系统特殊功能编写的部分，通常是不可
移植的

#cpp是c的超集，c在嵌入式系统编程中是流行语言

#编译器是把高级语言程序翻译成计算机能理解的机器语言指令集的程序

#1989、1990分别颁布c89和c90标准，1994颁布了c99标准：支持国际化编程、解决明显缺陷、提高c适应性

#c是编译型语言

#链接器程序来链接库函数，c编译器运行链接器，编译器把源代码转换成目标代码，链接器把目标代码、库函数
和启动代码合并成一个可执行性文件，unix下目标代码扩展名为.o，一旦链接器生成了完整的可执行程序就会将其
删除，如果原始程序有多个源代码文件，则保留目标代码文件，windows下不会删除

#unix c以前用的是cc编译，但淘汰了

#GUN项目是一个开发大量自由UNIX软件的集合，GUN编译器集合也称为GCC，是其项目之一，gcc别名cc，Clang也
可以编译c

#Linux是一个开源、流行、类UNIX的操作系统

#下载Cygwin和MinGW后，可以在命令行中调用gcc命令

									c语言概述
# #include 是预处理器指令；预处理：c编译器在编译之前会对源代码做一些准备工作；#表明c预处理器在编译
器接手之前处理这条指令

#int main(void) main函数是c程序开始的函数(ANSI C风格)，返回的值交给操作系统

#坚持使用标准形式，移植的时候就不会出问题

#旧标准规定，声明必须在块的顶部，而c99和c11则可以声明在块内任何位置

#c99和c11下允许使用很长的标识符名，编译器识别前63个字符

									数据和c
# 0开头表示8进制，占位符为%o或%#o；0x开头表示16进制，占位符为%x或%#x,%#X；显示前缀或不显示

#根据不同系统下long int short等占位不同，选择合适的数据类型以便移植，在头文件stdint.h和inttypes.h
中，可以进行类型控制

#默认情况下，编译器假定浮点型常量是double类型的精度，但可以在后面加f后缀以覆盖默认

#c99和c11下可使用%zd转换说明来匹配sizeof的返回类型，其他低版本可用%u或%lu来代替

#用%d显示float类型的值，其值不会被转换成int类型

									字符串和格式化输入输出
#printf()函数会把输出发送到一个叫缓冲区的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上
当缓冲区满、遇到换行符或需要输入的时候，会刷新缓冲区，然后打印在屏幕上，其函数中的格式字符串参数
不能分行

#c中没有字符串类型数据，一般用字符数组来存储，最后一位存\0，一般编译器自动加上

#scanf()函数从第一个非空字符开始，一般只会读取一个单词，遇到空格或其他符号或不符合类型的值时会停止，这些符号继续留在缓冲区
中，可用getchar()依次读取出；可以在%s中使用字段宽度，防止溢出

# #define MAX 1---程序中所有MAX都会被替换为1，这一过程被称为编译时替换，在运行程序时，程序中所有
替换均已完成；用大写表示符号常量是为了提高程序可读性

#系统中用二进制补码来表示有符号整数

									关系运算符
#在c中，编译器可以自行选择先对函数中的哪个参数求值，这样做提高了编译器的效率

#声明创建了名称和类型，并为其分配内存位置

#序列点是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生，c中语句中的分号标记了一个序列点，
任何一个完整表达式(即这个表达式不是另一个更大表达式的子表达式)的结束也是一个序列点

#缩进在c中对编译器不起作用，while {的风格突出了块附属于while循环

#c99和c11后，函数无参需要在括号内加void关键字

#使用术语argument表示实参，术语parameter表示形参

#;代表一个空语句，另起一行写空语句，方便阅读

#比较浮点数时，尽量只使用>和<，因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等

#在构建比较是否相等的表达式时，都习惯把常量放在左侧 便于检查语法错误

#c99中提供了stdbool.h头文件，让bool成为_Bool的别名

#,是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生；还有逗号表达式，整个逗号
表达式的值是右侧项的值，逗号优先级比赋值=高
          
#写算法时，先看看数学上是否有简单的方法可用

#c标准风格：main()通常只提供整个程序的框架，最好把main()放在所有函数定义的前面

#getchar(), putchar()专门的字符读取一个字符函数，速度比scanf()和printf()快，放在stdio.h中，是预
处理宏，不是真正的函数

#ctype.h有专门处理字符的函数，C primer plus - P156，无论什么类型的编码，都可以进行判断

#包含iso646.h头文件后，可用and、or等来代替逻辑运算符

#&&和||都是序列点，从左到右执行

									控制语句
#10 <= x <= 20运算顺序是(10 <= x) <= 20恒为真

#for()中使用break，则更新部分直接跳过，嵌套循环内层的break只会让程序跳出包含它的当前循环

#switch()圆括号中的测试表达式的值应该是一个整数值

#goto语句不要乱用，可以接收的一种用法是---出现问题时从一组嵌套循环中跳出

									字符的输入输出
#c把输入输出设备视为存储设备上的普通文件，尤其是键盘和显示设备视为每个c程序自动打开的文件

#c中用getchar()读取文件检测到文件结尾时将返回一个特殊值，即EOF，scanf()检测到文件结尾时也返回EOF
通常EOF定义在stdio.h中文件中，#define EOF (-1)

# < 符号是UNIX和DOS/Windows的重定向输入运算符，可使文件与stdin流相关联
  > 符号是UNIX和DOS/Windows的重定向输出运算符，可使文件与stdout流相关联
重定向运算符连接一个可执行程序和一个数据文件，不能读取多个文件输入，不能输出定向至多个文件
UNIX、Linux或Windows/DOS还有 >> 运算符，该运算符可以把数据添加到现有文件的末尾，而|运算符能把
一个文件的输出连接到另一个文件的输入

									函数
#函数签名：函数的返回值类型与函数接受的参数类型的信息

#旧版本的函数声明，可以不写入参数，或者在()内声明参数名称，(){}之间声明参数类型，或者只写入类型
如果未声明函数类型，会默认为int类型

#驱动程序：被设计用于测试函数的程序

#自定义函数也可以声明在主调函数(main)内部

#函数声明里的形参名是假名，函数定义的时候形参名字可以不一致

#main()也可以被自己或其他函数递归调用---尽管很少这样做

#指针存储的地址是由一个无符号整数表示，所以其类型实际上是一个新类型，所以ANSI C专门为指针提供了%p
格式的转换说明

									数组和指针
#标量变量：只储存单个值的变量

#数组初始化：arr[size] = {...};如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾
值；但是，如果部分初始化数组，剩余的元素就会被初始化为0
如果省略size，则编译器会自动匹配数组大小和初始化列表中的项数，但无法察觉初始化列表中的项数有误

#指定初始化器：int arr[6] = {[5] = 10};利用该特性可以初始化特定的数组元素，初始化最后一个值时，传
统的c必须初始化最后一个元素之前的所有元素，才能初始化它
如果指定初始化器后面更多的值，那么后面这些值将被用于初始化指定元素后面的元素
如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化
如果未指定元素个数，int stuff[] = {1, [6] = 23};那么编译器会把数组的大小设置为足够装得下初始化的值

#数组赋值：c不允许把数组作为一个单元赋给另一个数组，arr1 = arr2 //error
除初始化以外也不允许使用花括号列表的形式赋值

#如果访问越界数组下标，会改变数组外其他变量的值，类似于汇编中的ds区，变量和数组存储在连续空间中，
越界后可能会访问到变量
c信任程序员，不检查边界，可以使程序运行更快

#c99之前，声明数组时只能在方括号中使用整型常量表达式；表达式的值必须大于0；sizeof表达式被视为整型常
量，但const值不是(与C++不同)

#二维数组初始化时也可以省略内部的花括号，只保留最外面的一对花括号；只要保证初始化的数值个数正确，初
始化的效果与上面相同。但是如果初始化数值不够，则按照先后顺序逐行初始化，直到用完所有值。后面没有值
初始化的元素被统一初始化为0.
也可以用arr[size][]来不指定元素个数进行初始化

#因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达，因此
使用指针的程序更有效率

#指针指定类型，是为了在偏移+1时，偏移一个类型的大小，与数组偏移同步，与汇编中ds区偏移差不多

#在函数原型或函数定义头中，才可以使用int arr[]作为参数，但函数内部访问时，要指定数组大小

#实参中的arr[size]为实际大小，形参中的temp[]为8bytes，为一个指针的大小

#地址应该和指针类型兼容，不兼容的情况c99/c11已经强制不允许这样做

#如果一个函数按值传递数组，则必须分配足够的空间来存储原数组的副本，然后把原数组所有的数据拷贝至新的
数组中；如果把数组的地址传递给函数，让函数直接处理原数组则效率更高

#如果函数不希望改变主函数中的数组中的值，则形参上加上const关键字；
这样使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改；
这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样；
指向const的指针通常用于函数形参中，表明该函数不会使用指针改变数据

#函数形参中是非const，实参是const，则修改实参导致的结果是未定义行为

#数组指针：int (*ptr)[size]，指向一个内含两个int类型值的数组
指针数组：int* ptr[size]，是一个内含两个指针元素的数组，每个元素都是指向int的指针

#指针之间的赋值比数值类型之间的赋值要严格(类型转换中)

#C和C++中的const用法相似，但不完全相同：
区别之一是，C++运行在声明数组大小时使用const整数，而C却不允许
区别之二是，C++的指针赋值检查更严格，C++不允许把const指针赋给非const指针，而C则允许这样做，但是如果通过非const修改const
指向的值，则其行为是未定义的

#一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：int arr[][N1][N2]...[Nn]
因为第一对括号只用于表明这是一个指针，而其他方括号则用于描述指针所指向数据对象的类型，与int (*arr)[N1][N2]...[Nn]等价

#C规定，数组的维数必须是常量

#变长数组：c99新增了变长数组，允许使用变量表示数组的维度，变长数组必须是自动存储类别，都不能使用static或extern存储类别
说明符，而且不能在声明中初始化它们

#变长数组中的“变”不是指可以修改已创建数组的大小；一旦创建了变长数组，它的大小则保持不变；这里的“变”指的是：在创建数组时
可以使用变量指定数组的维度
变长数组允许动态内存分配，这说明可以在程序运行时指定数组的大小

#const int size = 10;	int arr[size];
c90不允许；数组大小必须是给定的整型常量表达式，可以是整型常量组合，如10，sizeof表达式或其他不是const的内容；由于c实现可以
扩大整型常量表达式的范围，所以可能会允许使用const，但是这种代码可能无法移植
c99/c11允许在声明变长数组时使用const常量，所以该数组的定义必须是声明在块中的自动存储类别数组

#字面量：除符号常量外的常量
复合字面量：(int [size]) {10, 20};	int [size]即是复合字面量的类型名
复合字面量是匿名的，不能先创建再使用，只能创建的同时使用它
复合字面量的类型名也代表首元素的地址
还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数，这种用法的好处是，把信息传入函数前不必先创建数组
复合字面量是提供只临时需要的值的一种手段，它具有块作用域，意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在
也就是说，复合字面量的定义在最内层的花括号内

									字符串和字符串函数
#puts()也属于stdio.h系列函数，但是puts()只显示字符串，而且自动在显示的字符串末尾加上换行符，遇到\0停止
gets()读取整行输入，直至遇到换行符，然后丢弃换行符，存储其余字符，并在这些字符的末尾添加一个空字符使其成为一个c字符串
但输入的字符串如果过长，可能会导致缓冲区溢出，segment fault说明该程序试图访问未分配的内存
所以gets()基本被舍弃不用了

#双引号中的字符和编译器自动加入末尾的\0字符，都作为字符串存储在内存中

#如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量

#字符串字面量属于静态存储类别，这说明如果在函数中使用字符串常量，该字符串只会被存储一次，在整个程序的生命期内存在，即使函数
被调用多次

#有\0的是字符串，没有的是字符数组

#让编译器计算数组的大小只能用在初始化数组时，如果创建一个稍后再填充的数组，就必须在声明时指定大小

#初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针

#建议在把指针初始化为字符串字面量时使用const限定符，如果打算修改字符串，就不要用指针指向字符串字面量

#如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高

#fgets(char*, int, file);第二个参数指明了读入字符的最大数量，如果是n，则读入n-1个字符，或读到遇到的第一个换行符为止
如果fgets()读到一个换行符，会把它存储在字符串中；超过了，后续字符程序员来处理
fgets()第三个参数指明要读入的文件，如果读入从键盘输入的数据，则以stdin作为参数，该标识符定义在stdio.h中
fgets()函数返回指向char指针，如果一切顺利，该函数返回的地址与传入的第一个参数相同；但是如果读到文件尾，将返回NULL

#fputs()函数的第二个参数指明它要写入的文件，如果要显示在计算机显示屏上，应使用stdout作为该参数
puts()函数会在待输出字符串末尾添加一个换行符，而fputs()不会这样做

#丢弃输入行余下的字符保证了读取语句与键盘输入同步

#完全可以在getchar()和putchar()的基础上自己造io函数！！！

#字符指针ptr如果指向\0，则*ptr = 0，可作为条件退出循环

#string.h中提供了处理字符串的函数
strlen()：统计字符串的长度
strcat()：接受两个字符串作为参数，把第二个字符串的备份附加在第一个字符串末尾，并把拼接后形成的新字符串作为第一个字符串，
第二个字符串不变，返回第一个字符串地址
strnact()：第三个参数指定了最大添加字符数
strcmp()：比较字符串中所有字符，不只是字母；参数是字符串不是字符；两串相等返回0，a在b前面返回负数，否则返回正数
strncmp()：第三个参数指定比较的字符数
strcpy()：第一个参数，目标地址；第二个参数：源地址，会拷贝\0，返回第一个参数的值
strncpy()：指定可拷贝的最大字符数，拷贝副本不一定有\0
sprintf()：第一个参数是目标字符串的地址，其余参数与printf()相同

#命令行参数是同一行的附加项
如fuss -r Ginger，一个c程序可以读取并使用这些附加项
int main(int argc, char* argv[])中，第一个参数表示计数参数(argument count)，第二个参数表示指针数组(argument value)，
存储附加项

										存储类别、链接和内存管理
#C中的一块内存称为对象，一个对象可能并未存储实际的值，但是它在存储适当的值时一定具有相应的大小

#作用域：描述程序中可访问标识符的区域；
1、块作用域：定义在块中的变量具有块作用域，虽然函数形参在花括号之前，但也具有块作用域，属于
函数体这个块；for、if等函数的后一句，即使没有花括号，也属于该块作用域
2、函数作用域：仅用于goto语句的标签；意味着：即使一个标签首次出现在函数的内层块中，它的作用域也延申至整个函数
3、函数原型作用域：用于函数原型中的形参名，范围是从形参定义处到原型声明结束；即：编译器在处理函数原型中的形参时，只关心
类型，不关心名字，即使有名字，也不必与函数定义中的形参名匹配，变长数组中，形参名才有用
4、文件作用域(全局变量)：变量的定义在函数的外面，从它的定义处到该定义所在文件的末尾均可见
一个翻译单元(.c和.h文件)中，也可以访问

#链接：三种链接属性：外部链接，内部链接，无链接
1、无链接：具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量
2、外部链接：具有文件作用域的变量可以在多文件程序中使用---int test
3、内部链接：具有文件作用域的变量可以在一个翻译单元中使用---static int test

#存储期
1、静态存储期：程序执行期间一直存在，文件作用域变量具有静态存储期(内部/外部链接均是)
2、线程存储期：具有线程存储期的对象，从被声明到线程结束一直存在；以关键字_Thread_local声明一个对象，每个线程
都获得该变量的私有备份
3、自动存储期：块作用域
4、动态存储期

#存储类别
1、自动变量：具有自动存储期，块作用域且无链接；关键字auto是存储类型说明符，与C++完全不同；自动变量不会初始化，除非显式
初始化它
2、寄存器变量：此变量存储在寄存器中，无法获取地址，绝大多数方面，寄存器变量和自动变量都一样；
使用存储类别声明符register声明寄存器变量(是一种请求，可能不会分配寄存器空间，但仍不能访问地址，变成普通的自动变量)
声明为register的数据类型有限，例如处理器中的寄存器可能没有足够大的空间来存储double类型的值
3、块作用域的静态变量：静态是指该变量在内存中的位置不变，而不是值不变；这种变量具有块作用域、无链接，但是具有静态存储期
static声明这组变量

#外部链接的静态变量：具有文件作用域、外部链接和静态存储期
外部变量如果未初始化，则被自动初始化为0；只能用常量表达式初始化文件作用域变量

#编译器识别局部标识符的前63个字符和外部标志符的前31个字符

#不要用extern创建外部定义，只用它来引用现有的外部定义

#内部链接的静态变量：具有静态存储期，文件作用域和内部链接

#尽量用自动存储类别，只共享那些需要共享的变量

#malloc()函数接受一个参数：所需内存的字节数；malloc会找到合适的空闲内存块，这样的内存是匿名的；
返回动态分配内存块的首字节地址，void类型的指针

#free()：参数是之前malloc()返回的地址，释放之前malloc()分配的内存；如果忘记销毁，则会造成内存泄漏

#calloc(size_t, sizeof)会把块中所有位都设置为0

#可以用malloc和free管理一个内存池，进行内存复用

#使用寄存器内存速度 > 栈区内存 > 堆区内存

#限定符：一条声明中多次使用同一限定符，多余的限定符将被忽略
1、const
2、volatile：告知计算机，代理可改变该变量的值，告诉编译器不要缓存中的变量而是内存中的变量
3、restrict：只能用于指针，表明该指针是访问数据对象的唯一且初始的方式；可以用于编译器优化
4、_Atomic：在头文件stdatomic.h和thread.h中

#1、time.h头文件中，提供了系统时间函数time()，返回值类型time_t具体类型与系统有关
 2、stdlib.h头文件中包含了随机数函数rand()和随机数种子函数srand((unsigned int) time(NULL));
										文件输入/输出
#I/O函数
1、fopen(char* addr, char* mode)
2、getc(fp)：从fp指定的文件中获取一个字符
3、putc(ch, fp)：把字符ch放入FILE指针fp指定的文件中
4、fclose(fp)：关闭fp指定的文件，必要时刷新缓冲区，关闭成功返回0，失败返回EOF；
如果磁盘已满、移动硬盘被移除或出现I/O错误，都会导致调用fclose()函数失败
5、stdin、stdout、stderr都是文件指针，不过定向在键盘和显示器上
6、fprintf()与fscanf()第一个参数是文件指针，其余与printf和scanf类似
7、rewind()函数让程序回到文件开始处
8、fseek(FILE*, int offset, long mode) mode: SEEK_SET、SEEK_CUR、SEEK_END
9、long ftell()返回的是参数指向文件的当前位置距文件开始处的字节数
10、fgetpos()、fsetpos()是fseek和ftell的扩展
11、fflush()刷新输出缓冲区，在输入流中使用fflush函数的效果是未定义的
12、size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* fp);成功返回nmemb，失败返回比nmemb小
13、size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict fp);
14、int feof(FILE* fp)和int ferror(FILE* fp);满足返回非零，失败返回0
#同时打开的文件数量是有限的，限制取决于系统和实现，范围一般是10~20

										结构和其他数据类型
#列表初始化：struct book library = {..., ..., ...};

#结构的初始化器：struct book gift = {.value = 10.99};

#现在的c允许把一个结构赋值给另一个结构，但是数组不能这样做，但是结构中的数组可以；还可以把一个结构初始化为相同类型
的另一个结构

#结构体中字符数组和字符指针，优先考虑数组，指针应该只用来在程序中管理那些已分配和在别处分配的字符串
如果使用malloc分配内存空间后用指针接受字符串，那么就比较合理

#复合字面量：如果只需要一个临时结构值，那么其很好用；语法是：(struct book) {"...", "..."};

#伸缩型数组成员：是结构的最后一个成员
1、不能用结构进行拷贝，因为不能拷贝伸缩型成员
2、不要以按值方式把这种结构传递给函数
3、不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员
4、这种类似于在结构中最后一个成员是伸缩型数组的情况，称为struct hack，是针对特殊编译器GCC的

#匿名结构：struct {..., ...};

#联合：union test {...};
1、能在同一个空间中存储不同的数据类型
2、联合只能存储一个值，所以编写代码时要注意当前存储在联合中的数据类型
3、多选一的时候用

#联合初始化
1、另一个联合初始化
2、列表初始化(只能初始化一项)
3、初始化器初始化

#匿名联合：union {...};

#枚举：enum test {};
1、可以用枚举类型声明符号名称来表示整型常量(实际上，enum常量是int类型，因此，只要用到int的地方就可以使用enum类型)
比如：声明数组时，可以用枚举常量表示数组的大小；在switch语句中，可以把枚举常量作为标签
2、C枚举的特性并不适用于C++，比如：C允许枚举类型使用++运算符，但是C++标准不允许
3、默认情况下，枚举列表中的常量都被赋予0、1、2等
4、在枚举声明中，可以为枚举常量指定整数值，如果只给一个枚举类型变量赋值，没有对后面的枚举常量赋值，那么后面的常量
会被赋予后续的值

#名称空间：是分类别的，在特定的作用域中的结构标记、联合标记和枚举标记都共享相同的名称空间，该名称不会与普通变量使用
的空间不同；但C++不允许这样做，它把标记名和变量名放在相同的名称空间中

#typedef：由编译器解释，不是预处理器；存在作用域

#函数指针：type (*ptr) (type);	函数名用于表示函数的地址
(*ptr)(arg)与ptr(arg)等价

										位操作
#逻辑运算符
1、按位取反：所有位，1变0，0变1 --- ~x
2、按位与：&x &=
3、按位或：|x |=
4、按位异或：^x ^=

#掩码：按位与运算常用于掩码，flag = flag & MASK;相当于把flag除了掩码中的含有1的位之外的位全部掩盖了
无论flag原来是多少位，最终的值都被修改为1个8位字节

#打开位：按位或运算

#关闭位：按位与运算 flag &= ~MASK;

#切换位：打开已关闭的位或关闭已打开的位，按位异或运算符 --- flags ^= MASK;

#检查位的值：(flags & MASK) == MASK; 避免信息漏过边界，掩码至少要与其覆盖的值宽度相同

#移位运算符：左移运算符<<= 右移运算符>>=

#位字段
是一个signed int或unsigned int类型变量中的一组相邻的位
通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度；struct {unsigned int code1 : 2;} prcode;

										C预处理器和C库
#C预处理器在程序执行前查看程序，编译器在预处理前会对程序进行一些翻译处理，处理后进入预处理阶段

#define
1、预处理器指令，其定义从指令出现的地方到该文件末尾有效
2、反斜杠可以把定义延续到下一行
3、宏扩展：从宏变成最终替换文本的过程
4、宏可以表示任何字符串，甚至可以表示整个C表达式，还可以嵌套宏(有些编译器不支持)
5、编译器在编译期对所有常量表达式求值，所以预处理器不会进行实际的运算，只进行替换
6、const可以创建在程序运行过程中不能改变的变量
7、重定义常量：只有新定义和旧定义完全相同才允许重定义(替换体中的记号必须相同，且顺序也相同)
8、变参宏：stdvar.h头文件提供了工具，让用户自定义带可变参数的函数
#define PR(x, ...) printf("message" #x ": " __VA_ARGS__)
9、宏和函数的选择实际上是时间和空间的权衡：宏生成内联代码，占用空间多，函数调用需要切换进程，占用时间多

#include指令
1、在UNIX系统中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号告诉预处理器首先在当前目录中查找该文件，如果未找到再
查找标准系统目录

#undef指令
1、取消之前的#define定义，如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用#undef指令取消该名字的定义

#条件编译
1、可以嵌套、可以标记C语句块
2、#ifdef指令说明，如果预处理器已经定义了后面的标识符，则执行#else或#endif指令之前的所有指令并编译所有C代码；如果预处理器
未定义，且有#else指令，则执行#else和#endif之间的所有代码
3、ifndef则与ifdef逻辑相反，通常包含多个头文件时，其中的文件可能包含了相同宏定义，此指令可以防止相同的宏被重复定义；通常也
用于防止多次包含一个文件
4、不能重复包含头文件的原因：在被包含的文件中有某些项只能在一个文件中出现一次

#if与#elif
1、#if后面跟整形常量表达式，如果表达式为非零，则表达式为真。可以在指令中使用C的关系运算符和逻辑运算符

#预定义宏和预定义标识符

#line指令重置预定义宏__LINE__和__FILE__报告的行号和文件名: #line 10 "cool.c"

#error指令让预处理器发出一条错误消息，该消息包含指令中的文本

#pragma
1、把编译器指令放入源代码中，如#pragma c9x on让编译器支持C9X标准
2、_Pragma预处理器运算符，把字符串转换成普通编译指示

#泛型选择表达式：不是预处理器指令，但是在一些泛型编程中它常用做#define宏定义的一部分

#内联函数：标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中；格式为：
inline static void func()，由于未给内联函数预留单独的代码块，所以无法获得内联函数地址，另外，内联函数无法在调试器中显示

#函数说明符_Noreturn，表明调用完成后函数不返回主调函数，exit()是其的一个示例

#头文件提供函数声明或原型，而库选项告诉系统到哪里查找函数代码

#main()返回系统时将自动调用exit()函数，可以通过atexit(函数指针)注册要在退出时调用的函数来指定在执行exit()时调用的特定函
数，注册的函数应该不带任何参数且返回类型为void

#exit函数在执行完atexit指定函数后会完成一些清理工作，然后把控制权返回主机环境，向主机环境报告终止状态

#C++要求在把void*指针赋给任何类型的指针时必须进行强制类型转换，而C没有这样的要求

#assert.h头文件
1、支持的断言库是一个用于辅助调试程序的小型库，由assert()宏组成，接受整形表达式作为参数，如果int为假，在stderr中写入错误
信息，并调用abort()函数终止程序. assert宏是为了标志出程序中某些条件为真的关键位置
2、将#define NDEBUG写在包含assert.h的位置前面，并重新编译程序，这样编译器就会禁用文件中所有的assert()语句，如果又出问题，
移出define即可
3、运行时检查

#_Static_assert声明，可以在编译时检查assert()表达式，接受两个参数，第一个是常量表达式，第二个是一个字符串，如果为false，
显示字符串

#memcpy假设两个内存区之间没有重叠，而memmove不作这样的假设