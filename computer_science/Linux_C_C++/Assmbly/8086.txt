mount c d:masm
c:
debug	//进入编辑模式
////////////////////////////////////////////////////////////////////////////////////////
d 内存地址	//查看内存内容
e 内存地址	//编辑内存内容
a 内存地址	//执行此处命令，默认是cs+ip处命令
r 		//查看所有寄存器，改变寄存器指向的地址
t		//执行cs+ip处的指令
u 内存地址	//翻译出内存内的指令
////////////////////////////////////////////////////////////////////////////////////////
ds寄存器：数据段地址，不能用立即数赋值，只能用寄存器赋值
mov ax, [1]	//ds为段地址，0001为偏移地址的数据
int 21：程序退出

t执行的是以cs为段地址，ip为偏移地址的内存中的指令
jmp bx	//将ip变为bx中的值
ss:sp	//栈顶指针，指向栈顶元素，初始指向栈底

bx可以存储一个偏移地址、bx可以与数字相加作为偏移地址也可以和si与di相加作为偏移地址
	[bx + si + number]或[bx + di + number]均可，但[bx + si + di]不行
si、di功能与bx相似，如果在[]中使用bx，默认段地址就是ds中的地址
bp与bx类似，如果在[]中使用bp，默认段地址就是ss中的地址
bp与bx两个只能用一个，si与di两个只能用一个
cx：计数器
ax：累加器
dx：数据寄存器
///////////////////////////////////////////////////////////////////////////////////////
mov不会导致标志寄存器发生变化，加减乘除会导致寄存器发生变化
adc：带进位的加法运算、只要cf为1，则运算均会带上这个进位
sbb：带借位的减法运算
cmp：与sub类似，不过不存储运算结果，只更新各个符号位状态，用于条件判断跳转
ja：大于
je：等于
jb：小于

编译运行过程-----伪指令只能通过编译来运行
1、进入masm模式进行编译
2、进入link模式进行链接
3、进入debug模式进行调试

s:
loop s 根据cx中的值判断是否跳转，跳转一次(cx)-1
g ip：一次性执行到指定位置
p：一次性执行完loop循环

用call s和ret作为函数使用

ret通过将ip出栈，改变ip地址实现短距离跳转指令
retf通过将cs和ip出栈，改变cs和ip地址实现长距离跳转指令
call通过将ip入栈，改变ip地址实现短距离跳转指令
call far ptr通过将cs:ip入栈，改变cs和ip地址实现长距离跳转指令


db、dw、dd定义一个字节或字或双字放入代码段中

;表示注释
comment**comment多行注释
