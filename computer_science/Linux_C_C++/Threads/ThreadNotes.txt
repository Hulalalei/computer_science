#Thread
#include <pthread.h>
g++ file.cpp -l pthread -o app -std=c++11


pthread_t pthread_self (void);                 //return current thread Id.
pthread_t tid;                                 //contain thread Id.


int pthread_create (pthread_t *thread, const pthread_attr_t *attr, void *(*start routine) (void *), void *arg);
//thread: point to the tid and provide Id to tid.
//attr: default = null, thread's attribute.
//start_routine: tasks.
//arg: transmit paras to tasks.


void pthread_exit(void* retval);              
//when the main thread exit, it'll not clear the memory space.
//retval: the main thread will get the retval, if retval is not necessary, you can set null.
//retval just like return tasks. retval can = struct para used in son thread.


int pthread_join (pthread_t thread, void **retval)
//used in main().
//block the son thread, when son use pthread_exit(), son'll be unblocked. and main thread recycle son's core resource.
//it can recycle one thread each time.
//son thread can release the stack resource but can't release the core resource.
//thread: son's thread Id which need to be recycled
//retval: point to pthread_exit() transmited data address. like retval->&ptr, ptr->data address. ptr, first level point.
//if return 0, it's succeed, if other returns, it's failure.


int pthread_detach (pthread_t thread);
//detach the main thread and son thread, when son threaed exit(), main will not be blocked and core can recycle son's resource.
//thread: target son thread to be detached.


int pthread_cancel (pthread_t thread);
//kill the target thread.
//return 0 is ok, other is wrong. used in main().


int pthread_equal (pthread_t t1, pthread_t t2);
unequal, return 0; equal, return != 0.











#Thread synchronization
cpu(registers) -- cache Lv1 -- cache Lv2 -- cache Lv3 -- memory		//process of threads


pthread_mutex_t mutex;		
//thread use this unique mutex to lock resource.
//keep the mutex is valid during the thread synchronization.


int pthread_mutex_init (pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);		
//init the lock
//restrict modify this pointer, other pointers = pointer can't visit the memory space.
//attr: default = null; (mutex_lcok's attribute)

int pthread_mutex_destroy (pthread_mutex_t *mutex);			//release the mutex_lock resource


int pthread_mutex_lock (pthread_mutex_t *mutex);			//modify the lock's status to locked.


int pthread_mutex_trylock (pthread_mutex_t *mutex);			//if the lock is locked, other threads will not be blocked, return a wrong number.


int pthread_mutex_unlock (pthread_mutex_t *mutex);			//modify the lock's statue to unlocked.





pthread_rwlock_t rwlock;
//super version of mutex_lock
//if threads read a lot, use it; if threads write a lot, either is ok.


int pthread_rwlock_init (pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);		//init the rwlock


int pthread_rwlock_destroy (pthread_rwlock_t *rwlock);								//release the resource


int pthread_rwlock_rdlock (pthread_rwlock_t *rwlock);								//readlock again will not be blocked.


int pthread_rwlock_wrlock (pthread_rwlock_t *rwlock);								//writelock again will be blocked.


int pthread_rwlock_unlock (pthread_rwlock_t *rwlock);								//release the lock's resource.


int pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock);							//try to lock, will not be blocked.


int pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock);							//try to lock, will not be blocked.


pthread_cond_t cond;
//awake or block threads


int pthread_cond_init (pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);			//init the cond


int pthread_cond_destroy (pthread_cond_t *cond);								//destroy the cond


int pthread_cond_wait (pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);				//block the threads


int pthread_cond_timedwait (pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); //block threads with limited time.
//struct timespec {
	time_t tv_sec;
	long tv_nsec;
};
//time_t mytim = time(NULL); //time from 1970.1.1
struct timespec tmsp;
tmsp.tv_nsec = 0;
tmsp.tv_sec = time(NULL) + 100;//the futher 100 seconds


int pthread_cond_signal (pthread_cond_t *cond);									//awake one blocked thread at least


int pthread_cond_broadcast (pthread_cond_t *cond);								//awake all blocked threads











#semaphore
#include <semaphore.h>
sem_t sem;


int sem_init (sem_t *sem, int pshared, unsigned int value);
//pshared: design synchronized process or threads
//value: number of source, if value == 0, block the process or thread.


int sem_destroy (sem_t *sem);
//destroy the semaphore.


int sem_wait (sem_t *sem);
//value-- each time, when value == 0, block the process or thread.


int sem_trywait (sem_t *sem);
//try to decrease the source.


int sem_post (sem_t *sem);
//value++ each time.


int sem_getvalue(sem_t *sem, int *sval);
//get the value of source.
//sval: put a pointer in it, it will give back a pointer point to the value.


int sem_timewait (sem_t *sem, const struct timespec *abs_timeout);
//set the limited time.
