===共享栈===
两个栈的栈底位于一个1维数组的两端

===三对角矩阵压缩===
一维数组B[k]与二维数组A[i][j]的映射关系：k = 2i + j - 2


===入栈顺序确定，求出栈顺序个数===
cnt = (1/(n+1)) * C(n, 2n)



                                                            ===树与二叉树===
===树的性质===
    = 树中的节点数等于所有节点的度数之和加1
    = 树的路径长度：是从树根到每个节点的路径长度
    = 根到每个节点的路径长度最大值：树的高度 - 1

===二叉树的性质===
    = 非空二叉树的叶节点数等于度为2的节点数加1
    = 度为1的节点个数为奇数
    = 完全二叉树n节点，高度h=log2(n+1)上取整，或h=log2n + 1下取整
    = 也可以把树的高度看成 一系列的01串，只不过是全1的
    = 高度为h的二叉树只有度为0和2的节点，则其所包含的节点树至少有2h-1个

===指针个数问题===
    = 非空指针：指向节点的分支数
    = 总分支数 = 节点数-1
    = 总的指针域 = 2n
    = 空指针：2n - (n - 1)

===先中后序遍历===
    = 后序遍历和先序遍历不能唯一确定一颗二叉树
    = 先序序列第一个序列点 确定根节点、后序序列最后一个序列点 确定根节点
    = 中序序列任意节点，可找到剩下节点关于此节点在其左子树还是右子树中
    = 先序序列确定，求二叉树个数时，和求出栈个数是一样的

===线索二叉树：多余的空悬指针，作为线索，指向前驱或后继
    = rtag/ltag = 1表示线索化，为0指向孩子
    = 线索化，就是遍历一次二叉树，然后把指针指向前驱或后继的过程
    = 其前驱和后继节点，由遍历方式决定
    = 线索化后，后序线索树中求后序后继问题，仍不能有效解决
         

===树的存储结构===
    = 双亲表示法：连续空间存储，每个节点存储一个双亲index
        struct node { T data; int parents; };
        struct tree { node arr[N]; int node_cnt; };

    = 孩子表示法：将每个节点的孩子节点都用链表链接起来；
        类似于邻接表
        
    = 孩子兄弟表示法：二叉链表存储
        struct node { T data; struct node *fisrt_child, *next_child; };

===树、森林与二叉树的转换===
    = 树转换为二叉树：每个节点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟；"左孩子右兄弟"
    = 森林转换为二叉树：先将森林中每颗树转换为二叉树，再把第i+1颗树作为第i颗树的右兄弟......
    = 二叉树转换为森林：反过来拆分即可


===哈夫曼树===
= 只有度为0和2的点
= 每次选取最小的两个节点进行合并
= 根据频率不同，选取频率最小的两个节点合并后，构造出的哈夫曼树，左孩子为0,右孩子为1可以进行哈夫曼编码
= 定长编码集：所有编码结果均在叶子节点


===并查集===
= 双亲表示法
= 1-2表示把2的集合合并到1的集合中




                                                                    ===图===
===图的性质===
    = 如果一个图有n个顶点和n-1条边，则恰好是无环图，如果有n条边，则一定有环

    = 无向图的全部顶点的度的和等于边数的2倍

    = 简单图：不存在重复边、不存在顶点到自身的边

    = 完全图
        = 有n(n-1)/2条边的无向图称为完全图；
        = 有n(n-1)条边的有向图称为完全图；

    = 连通图
        = 若无向图中任意两个顶点都是连通的，则称为连同图；
        = 无向图的极大连通子图称为 连通分量
        = 一个连通的生成树是一个极小连通子图

    = 强连通图和强连通分量
        = 有向图中，如果两点之间均有双边，则称为强连通图
        = 极大强连通子图称为强连通分量


===图的存储===
    ===邻接矩阵===
    = 无向图的矩阵一定是对称矩阵
    = 唯一

    ===邻接表===
    = 不唯一

    ===邻接多重表===
    = 存储无向图


    ===十字链表===
    = 存储有向图


===边角料===
    = 欧拉路径EL：度数为奇数的顶点的个数是不超过2的偶数
    = DFS可以判断图的回路


===最小生成树===
    = 一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边
    = 砍去一条边，会变成非连通图；加上一条边，会形成回路
    = 生成树不唯一，但如果各边权值互不相等时，是唯一的
    = 权值总和是唯一的，都是最小的、

    = Prim算法
        = 初始时，选取一点加入树T中；
        = 之后选择一个与当前T中顶点集合距离最近的顶点，并将其边和点加入T中
    = Kruskal算法
        = 将边的权值排序，依次选取当前未被选取过且权值最小的边，若该边不构成回路，则将此边加入T；
        = 否则舍弃而选择下一条权值最小的边
        = 直到所有顶点都在一个连通分量上


===最短路径算法===
    = Dijkstra
        = 不适合求负权值最短路径
        = 由于每次选取的是最短边的点，且不可能曲线救国，所以一定是到此点的最短路径
        = 每次均选取距离集合T(min{dist[]})中最短边的点，更新其他相关距离
        = dist[]始终表示0点到其他所有点的最短距离
    = Floyd
        = 三重循环

===拓扑排序===
    = AOV网：若用DAG图表示一个工程，其顶点表示活动，用有向边表示<Vi, Vj>活动Vi必须先于活动Vj这样的关系，则这种图称为顶点表示活动的网络，即AOV网
    = 拓扑排序定义：每个顶点出现且只有一次
    = (1) 从AOV网中选择一个入度为0的点
    = (2) 删去此点和所有以它为起点的有向边
    = 重复1和2直到当前的AOV网为空或当前网中不存在入度为0的点为止

    = 若一个有向图的邻接矩阵的对角线以下元素为0，则该图的拓扑排序一定存在，但不一定唯一；
        但若对角线以上元素均为1,以下元素均为0，则该拓扑排序唯一

===关键路径===
    = 在带权有向图中，以顶点表示事件、有向边表示活动，以边上权值表示完成该活动的开销，称之为用边表示活动的网络，即AOE网
    = 仅在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始
    = 只有在进入某顶点的各有向边所代表的活动都已结束，该顶点所代表的事件才能发生
    = 关键路径：具有最大路径长度的路径
    = 关键路径不能随意缩短，可能会变成非关键路径
    = 缩短所有关键路径上共有的任意一个关键活动的持续时间可缩短关键路径长度

    = 事件的最迟发生时间：min{ 以该事件为尾的弧的活动的最迟开始时间, 以该事件为尾的弧所指事件的最迟发生时间与该弧的活动的持续时间之差 }
    = 正向推(源点到汇点)，得发生最早时间；反向推(汇点到源点)，得发生最迟时间






                                                                ===查找===
===顺序查找===

===折半查找===
    = 判定树高度：log2 (n + 1)上取整，包括查找失败节点
    = 且判断树为平衡二叉树
    = 通过画判断树来算查找成功/失败的平均查找长度

===分块查找===
    = 索引顺序表ASL = (b + n/1 + 2) / 2，理想块长为根号n
    = 平均查找长度 = 索引长度 + 块内长度

===二叉排序树===
    = 按序插入，是一个不平衡树，查找长度最长，为n
    = 删除的话，看着调树的位置即可

===平衡二叉树===
    = n0=0, n1=1, n2=2, nh=1 + nh-1 + nh-2(nh为构造平衡二叉树所需的最少节点数)
    = P267插入旋转

===B树 & B+树===
    = B树
        = 性质
            = m阶B树是所有节点的平衡因子均等于0的m路平衡查找树
            = 树中每个节点至多有m颗子树，即至多含有m-1个关键字
            = 若根节点不是叶节点，则至少有两颗子树
            = 除根节点外的所有非叶节点至少有m/2上取整，至少m/2上取整-1个关键字
            = 每个节点关键字(K1, k2, ...)，大于K1的放在后面，小于K1的放在前面......
                = 关键字从左到右递增有序
            = 叶节点对应 查找失败
            = 仅支持随即查找

        = B树中大部分操作所需的磁盘存取次数与B树的高度成正比
        = h >= logm (n + 1)
        = h <= logm/2 ((n + 1) / 2) + 1

        = B树插入：节点分裂，中间位置m/2上取整 将其中的关键字分为两部分
        = B树删除：节点合并，兄弟够借，借兄弟；不够，取父节点；如果满足最小关键字个数，则直接删

    = B+树
        = 应数据库所需而出现的
        = 支持随即查找和顺序查找
        = 叶节点包含信息，所有非叶节点仅起索引作用
        = 叶节点进行横向链接
        = 关键字个数和分支数一样


===散列表===
    = 构造方法
        = 直接定址法：H(key) = a * key + b
        = 除留余数法：H(key) = key % p (p为质数)
        = 数字分析法：判断r进制位数分布频率
        = 平方取中法：取key的平方值的中间几位作为H(key)

    = 处理冲突方法
        = 开放定址法：Hi = (H(key) + di) % m
            = 线性探测法：di = 0, 1, ...; 会造成大量元素在相邻位置"聚集"，查找效率低
                = 聚集/堆积：同义词冲突的探查序列和非同义词之间不同的探查序列交织在一起，导致关键字查询需要经过较长的探测距离
            = 平方/二次探测法：di = 0^2, 1^2, - 1^2...   (K <= m/2 && m = 4k + 3为素数)
            = 双散列法：设置两个散列表，第一个冲突后，用第二个
            = 伪随即序列法：di = 伪随即序列
            
            = 删除元素时，只能伪删除

        = 拉链法：所有同义词存储在一个线性链表中

    = 装填因子：alpha = 表中记录数n / 散列表长度m






                                                              ===排序===
= 根据数据元素是否完全在内存中，可将排序算法分为两类：内部排序、外部排序
= 大多数的内部排序算法只适用于顺序存储的线性表

= n个关键字基于比较的排序，至少需要log2 (n!)上取整 次


===插入排序===
    = 每次将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成
    = 更适用于基本有序的排序表和数据量不大的排序表

    = 直接插入排序(稳定排序)
        = 查找有序表时，顺序从后往前查找，再插入
        = 空间复杂度：O(1)
        = 时间复杂度(平均)：O(n^2)

    = 折半插入排序(稳定排序)
        = 查找有序表时，折半从后往前查找，再插入
        = 时间复杂度(平均)：O(n^2)

    = 希尔排序/缩小增量排序(不稳定排序)
        = 先分成一系列子表，对子表进行直接插入排序，当整个表呈现基本有序时，再对全体记录进行一次直接插入排序
        = 把相隔某个增量的记录组成一个子表

===交换排序===
    = 指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置
    = 冒泡排序(稳定)
        = 空间复杂度：O(1)
        = 时间复杂度(平均)：O(n^2)
    
    = 快速排序(不稳定)
        = 从头找到比基准元素大的数，交换两者位置；再从尾找到比基准元素小的数，交换两者位置；；
        = 基本有序性能低；数据分布较随机时，性能好；数据越多，性能越好
        = 所有内部排序中，平均性能最好的
        = 空间复杂度：O(log2 n)
        = 时间复杂度(平均)：O(n^2)
        = 最大递归深度：n；最小递归深度：log2 n

===选择排序===
    = 比较次数与序列无关
    = 每一趟在后面待排元素中选取关键字最小的元素，作为有序子序列的第i个元素，与L(i)交换位置，直到n-1趟做完
    = 简单选择排序(不稳定)
        = 空间复杂度：O(1)
        = 时间复杂度(平均)：O(n^2)，比较次数始终为n(n-1)/2
        = 移动次数O(n)，最少：0
    
    = 堆排序(不稳定)
        = 大根堆：L(i) >= L(2i) && L(i) >= L(2i + 1)，交换L(2i)和L(2i + 1)较大的
        = 空间复杂度：O(1)
        = 时间复杂度(平均)：O(nlog2 n)
        = 插入和删除 时间复杂度均为log2 n

        = 是个完全二叉树，因为数组前n个都有元素
        = 从n / 2 ~ 1进行初始化，依次比较然后交换位置
        = 输出根节点后，最后一个节点作为根节点；向下down
        = 插入节点x后，x从最下面up
        = 调整堆时，从序列末尾开始向前遍历
        = 如果插入是一个序列，则只能插入一个，调整一次......

===归并排序===(稳定，外部排序)
    = 比较次数与序列无关
    = 空间复杂度：O(n)
    = 时间复杂度：O(nlog2 n)

===基数排序===(稳定的)
    = 空间复杂度：O(r)
    = 时间复杂度：O(d(n + r))与序列初始状态无关
    = 递减排序：先根据个位大小排序，再根据十位排序(此时，个位递减)，再根据百位排序(此时，十位是递减的)
    = 0 1 2 3 4 5 6 7 8 9：下面链接节点
    = d较小、关键字取值不大、元素个数不大



= 注意区分：趟数、移动次数、时间复杂度

===外部排序===
    = 优化：减少内存与外存的归并趟数，要么减少归并段数，要么增加归并路数

===k路平衡归并===
    = 最多只能有k个段归并为一个
    = 每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到m/k上取整个新的归并段

===败者树===
    = 减少关键字对比次数
    = 非叶子节点记录失败者
    = 完全二叉树
    = 如果冠军走了，底层又来了一个人选举，则只需要和一半的人打架即可
    = 多个归并段选取最小/大值
    = 有了败者树，选出最小元素，只需要对比关键字log2 k上取整次

===置换选择排序===
    = 进一步减少初始归并段数量
    = 设置一个工作区WA(容量为n)，从待排序序列中，依次取n个放入WA中；取出最小的一个，且比上一个最小数要小，否则找次小的；放入归并段1中
    = WA满后，且均大于最小值，则归并段1构造结束；
    = 归并段2同理
    = 输出缓冲区满后，把结果写回外存


===最佳归并树===
    = 归并长度不同的两个序列
    = 磁盘IO次数 = 归并树WPL * 2
    = 哈夫曼树优化，依次选取长度最小k个节点

    = 对于k叉归并，若初始归并段个数无法构成严格的k叉归并树，则需要补充几个长度为0的"虚段"，再进行k叉哈夫曼树的构造
        = 否则构造的不是最佳归并树

    = k叉归并树一定是一颗严格的k叉树，只包含度为k和0的点
        = 初始归并段数量 + 虚段数量 = n0
        = n = n0 + nk
        = k * nk = n - 1
            = n0 = (k - 1)nk + 1
            = nk = (n0 - 1) / (k - 1)为整数
            = 如果 (n0 - 1) % (k - 1) == 0，刚好构成k叉
            = 如果 (n0 - 1) % (k - 1) == u，则补充(k - 1) - u个虚段





