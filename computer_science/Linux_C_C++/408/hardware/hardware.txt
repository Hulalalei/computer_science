                        第一章、计算机系统概述


# 计算机硬件基本组成：中央处理器，存储器，外部设备和设备控制器，总线


# 在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如1Kb=2^10b；在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如1kb/s=10^3b/s
	为了避免歧义，二进制用KiB、MiB表示


# 个人计算机由主机和外设组成，主机中包含多个电路板，每个电路板上有十几个集成电路组成，每个集成电路中有十几个模块，每个模块中有上千万个单元，每个单元由门电路组成


# 计算机软件：应用软件，系统软件(os，编译器，数据库管理系统，磁盘碎片整理程序，备份软件)


# 计算机系统抽象层次：
硬件(电子工程师(器件、电路)，架构师(功能部件/RTL、微体系结构))
软件(程序员(os/虚拟机、编程、算法)，最终用户(应用问题))
硬件软件之间的接口：架构师(指令集体系结构ISA)


# 翻译程序类型：
1、汇编程序：也称汇编器，用来将汇编语言源程序翻译成机器语言目标程序
2、解释程序：也称解释器，用来将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行
3、编译程序：也称编译器，用来将高级语言源程序翻译成汇编语言或机器语言目标程序


# 操作系统原语：具有原子性，实现os中的关键功能：进程管理、内存管理、文件系统、同步机制、网络通信；通过关中断来实现原子性


# 指令执行过程中所包含的所有操作都具有先后顺序关系，因此需要定时信号进行定时、同步


# CPU、主存和IO模块通过总线互连


# CPU包含：
1、运算器(ALU，通用寄存器组(GPRs)，累加器ACC，乘商寄存器MQ，操作数寄存器X，变址寄存器IX，基址寄存器BR，程序状态寄存器PSW)
2、控制器(PC，IR，控制单元CU)
3、MDR(位数由存储字长决定)，MAR(位数由地址码长度决定)，均是寄存器
4、寄存器组
5、总线接口


# 冯·诺依曼机的基本工作方式：控制流驱动方式；工作方式基本特点：按地址访问并顺序执行指令


# 计算机位数/字长/机器字长：计算机进行一次整数运算所能处理的二进制数据的位数，数据运算的基本单位长度，
				一般等于内部寄存器的位数大小，也是CPU内部整数运算的数据通路的宽度


# 字：用来表示被处理信息的单位，用来度量数据类型的宽度


# 数据字长：数据总线一次能并行传送信息的位数


# 数据通路带宽：指数据总线一次所能并行传送信息的位数（指外部数据总线的位数，与内部数据总线位数可能不同）


# 位数与机器字长相同的是：运算器中的寄存器


# 存储字：计算机主存以8bits为存储单位，8bits即为存储字长，存储的内容为存储字；存储字长可以是1B或是字节的偶数倍


# 系列机：是由同一厂家生产的具有相同系统结构的一系列不同型号的计算机


# 固件：将程序固化在ROM中组成的部件称为固件；具有软件特性，执行速度比软件快，灵活性高于硬件（目前os已实现了部分固化）


# 相联存储器CAM：一种不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表，即可以按照地址寻址也可以按照内容寻址


# 寄存器由触发器构成


# os的命令和指令不是一回事

===早期三级时序系统===
# 指令周期：取出一条指令并执行这条指令的时间，由多个CPU周期组成
# CPU周期：即机器周期，包含若干个时钟周期，执行基本操作(取指/读操作数/执行并写结果)所需时间
    = 又有多个节拍；一个节拍又有多个脉冲
# 工作脉冲：控制器最小时间单位，一个时钟周期包含一个工作脉冲

= 时钟脉冲信号：由机器脉冲源发出的脉冲信号，经整形和分频后形成

= 时钟周期：以相邻状态单元间组合逻辑电路的最大延迟为基准确定

# 取指或译码时更新pc中的地址


# 计算机系统性能评价
1、性能定义：
	用户感觉到的执行时间，分为：用户CPU时间和其他时间
		而用户CPU时间需要几个重要参数：
				时钟周期：CPU的主脉冲信号，宽度称为时钟周期
				时钟频率：主脉冲信号的时钟频率
				CPI：执行一条指令所需的时钟周期数，cycles per instruction
	用户CPU时间 = 程序总时钟周期数 / 时钟频率 = 程序总时钟周期数 * 时钟周期
	综合CPI：该程序或该机器指令集中的所有指令执行所需的平均时钟周期数（sigma (CPIi * percent)）
	程序总时钟周期数 = 程序总指令条数 * 综合CPI
	计算机性能：1 / 用户CPU时间


2、用指令执行速度进行性能评估
	MIPS：million instructions per second
		先计算一百万条执行执行所需时间，取倒数，得MIPS
	浮点数执行速度指标：
		MFLOPS：10^6次/s、GFLOPS：10^9次/s、TFLOPS：10^12次/s、PFLOPS：10^15次/s、EFLOPS：10^18次/s


3、Amdahl定律：对系统中某个硬件部分，或者软件中的某部分进行更新所带来的系统性能改进程度，取决于该硬件部件或软件部分被使用的频率或其执行时间占总时间的比例
	tip：该定律定义了增强或加速部分部件而获得的整体性能的改进程度
	公式：改进后的执行时间 = 改进部分执行时间 / 改进部分的改进倍数 + 未改进部分执行时间
	公式：整体改进倍数 = 1 / (改进部分执行时间比例 / 改进部分的改进倍数 + 未改进部分执行时间比例)









						第二章、数据的机器级表示


# 补码用来表示带符号整数
   原码用来表示无符号整数；也可以表示有符号数，但是没用这个方法


# 用原码表示的小数或整数，取补码规则都是相同的（非IEEE格式）


# 原码整数范围(0有两种表示方法)：-(2^n - 1) <= x <= 2^n - 1
   补码整数范围(0只有一种表示：000000)：-2^n <= x <= 2^n - 1
   移码整数范围(只能表示整数；0只有一种表示：100000)：


# 原码小数范围：1/2 <= M <= (1 - 2^n)；-(1 - 2^n) <= M <= -1/2


# 真值：这种带"+-"符号的数称为真值，真值是机器数所代表的实际值


# 机器数：把符号数字化的数称为机器数


# 补码，原码相互转换：若为负数，符号位不变，其余位取反，末尾加1
若为正数，原码和补码相同


# 反码，原码相互转换：若为负数，符号位不变，其余位取反


# 若用取模运算得补码，则补码＝2^M - |x|，x为真值，最后化为无符号二进制作为补码


# 移码用来表示浮点数的阶码，在真值X上加一个偏置值，通常取2^n(机器字长为n+1)


# 同一个数的补码和移码表示，其数值部分相同，而符号相反





						第三章、运算方法和运算部件


# 算术补码移位规则：负数右移添1，负数左移添0


#  算术移位：符号位不变，其余移动；
   逻辑移位：视为无符号数，直接移动；
   算术右移：负数，高位补1，正数，高位补0
   逻辑右移：负数，高位补0，正数，高位补0
   左移：全补0


# 加数X，Y，进位C，本位和F
进位传递函数P，进位生成函数G
溢出标志OF，符号标志(和的符号)SF，零标志ZF，进位/借位标志CF


# SF对于无符号数无意义
   CF对于带符号数无意义，无符号数溢出判断
   OF对于无符号数无意义，有符号数溢出判断


# 无论是补码减法还是无符号减法，都是用被减数加上减数的负数的补码来实现的


#补码加减运算溢出判断方法：
单符号位
	1' 符号不变即为不溢出，符号改变即为溢出
    2' 最高进位Ci和Ci-1异或
双符号位(也称为模4补码)：
S1S2为00表示结果为正数，无溢出
S1S2为01表示结果正溢出
S1S2为10表示结果负溢出
S1S2为11表示结果为负数，无溢出
模4补码存储时只需要一个符号位，只在ALU中采用双符号位


# 变型补码：即用两个二进制位来表示数字的符号位，其余与补码相同


# 原码乘法：
1、确定乘积的符号位
2、计算乘积的数值位


# 补码一位乘法：符号位和数值位一块算
   补码两位乘法：把乘数分为两位一组，根据两位代码的组合决定加或减被乘数的倍数，形成的部分积每次右移两位


# 补码加减法：
1、sub为0：减法，sub为1：加法；sub控制多路选择器，作为进位传到ALU
2、符号位和数值位一起参与运算
3、[A + B]补 ＝ [A]补 + [B]补
[A - B]补 ＝ [A]补 + [-B]补


# 大端方式，小端方式
存放立即数时，先存放低位值，再存放高位值


# 由[x]补求[-x]补：连同符号一起变反，末位加1


					=======IEEE========
# unsigned int和int占用字节数一样
short同理


# 数据类型转换规律：char->int->long->double


# 基数：作为进制的数


# 浮点数的IEEE标准对尾数编码采用原码，阶数采用移码


# 尾数中会隐含整数部分的1，加上后有24位


# 对阶：一般都是向大的阶对齐，所以不存在阶码减小的情况


# 尾数求和：求和完后，进行规格化


# 尾数为补码的规格化表示是小数点后一位与符号位不同
   尾数为原码的规格化表示是小数点后2位(基数为4，用2位表示)不全为0的小数


# 舍入是浮点数的概念，定点数没有舍入的概念；浮点数舍入的情况有两种：对阶、右规格化(由于运算结果只可能是1x.x，所以如果右规，仅需规格化一次)
	== 为保证运算精度，一般将低位移出的两位保留下来，参加中间过程的运算，最后将运算结果进行舍入，还原成IEEE格式
	== 舍入方法：
		1、0舍1入法：类似于十进制四舍五入；运算结果保留最高位数为0，则舍去；最高数位为1，则在尾数的末位加1；可能会导致尾数溢出，需要再右规一次
		2、恒置1法：不论丢掉的最高位是0还是1，都把右移后的尾数末位恒置1
		3、截断法：直接截取所需位数，丢弃后面的所有位


# 阶码全为1时，指数上溢；阶码全为0，指数下溢
   全0阶码全0尾数：+-0
   全1阶码全0尾数：+-∞


# IEEE 754单精度浮点数：符号位1位，阶码E有8位(1～254)，尾数23位(隐含一位1)；
	1、真值：(-1)^S * 1.M * 2^(E-127)
	2、最小值：1.0 * 2^(1 - 127) = 2^-126
	3、最大值：2^127 * (2 - 2^-23)
   IEEE 754双精度浮点数：符号位1位，阶码E有11位(1~2046)，尾数52位(隐含一位1)；
	1、真值：(-1)^S * 1.M * 2^(E-1023)
	2、最小值：1.0 * 2^(1 - 1023) = 2^-1022
	3、最大值：2^1023 * (2 - 2^-52)


小数转IEEE：
	1、确定符号位0或1
	2、找阶码，阶码真值可以是正数或负数，加上127后，恒为正；把尾数规格化为1.x后得到阶码
	3、尾数跟在阶码后面写上

                                                            第四章、指令系统
= 定长操作码编码：
RR型：两个操作数和结果都在寄存器中
RX型：寄存器-存储器型，二地址指令，第一个操作数在R1，另一个在存储器
RS型：寄存器-存储器型，三地址指令，R1存放结果，R3存放一个源操作数，另一个源操作数有效地址：EA=(B)+D
SI型：存储器-立即数型，结果和其中一个源操作数地址共用一个存储单元
SS型：存储器-存储器型，两个操作数都是存储器中的内容

= 指令字长是字节的整数倍

= 程序浮动：程序可以随机的从主存储器的一个区域移动到另一个区域，丝毫不影响它的执行

= 不论是无符号数还是带符号数，都以二进制无差别存放在机器内；即便是两个带符号数相加，也会导致CF的变动，只是CF的结果对带符号数是没有意义的

= CF = Cout(运算是否产生进位) xor Sub(是否是减法)

    = CISC和RISC的比较
    RISC的优点：
    = RISC更能充分利用VLSI芯片的面积；CISC的控制器大多采用微程序控制，其控制存储器在CPU芯片内所占面积达50%以上，而RISC控制器采用组合逻辑控制，其
    硬布线逻辑只占CPU芯片面积的10%左右
= RISC更能提高运算速度；指令种类少、定长、常用，设有多个通用寄存器，减少访存；采用流水线技术(必须实现的，大多数指令在一个周期内完成)
    = RISC便于设计，降低成本，提高可靠性
    = RISC有利于编译程序代码优化



                                                ===第五章、中央处理器===

= RISC普遍采用硬布线控制器(有限状态机)

# 控制器组成：程序计数器PC，指令寄存器IR，存储器地址寄存器MAR，存储器数据寄存器MDR，指令译码器，时序电路，微操作信号发生器

# 时钟周期：计算机操作的最小时间单位，由计算机主频确定，是主频的倒数
    工作脉冲：控制器的最小时间单位，起定时触发作用，一个时钟周期有一个工作脉冲
    指令周期：由多个CPU周期(机器周期)组成
CPU周期：包含若干时钟周期，指令执行中每步操作所需要的时间，或通过一次总线事务访问一次主存或IO的时间定为一个机器周期(存取周期)

= 数据通路结构：CPU内部单总线/多总线；专用数据通路

# 微程序控制存储器属于CPU的一部分

# 微指令确定下条指令的方法：断定法(下地址字段法)

# 控制存储器CM/CS用ROM

#寄存器间接寻址：找的是操作数在主存中的位置

# 微指令寄存器和指令寄存器对程序员透明

# 指令周期包含：取指周期，间址周期，执行周期，中断周期
    T0～T2为节拍

# 中断(外中断)：当前指令执行后进行检测
# 异常(内中断)：故障，陷阱，终止，当前指令执行过程中进行检测

# 动态流水线：在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算

# 超标量流水线：通过内置多条流水线来同时执行多个处理器，一条指令分为多段指令由不同电路单元完成

# 突发传输：同一行中，相邻的存储单元连续进行数据传输的方式，连续传输的周期数就是突发长度



= 控制器可采用硬连线路方式，也可采用微程序设计方式实现

= 组合逻辑元件(操作元件)：其输出只取决于当前的输入
= 存储元件(状态元件)

= 寄存器是典型的状态存储元件，n个触发器可构成一个n位寄存器

= 每个时钟周期下降沿经过触发器锁存延迟(Clk-to-Q)，前一个时钟周期内组合逻辑生成的信号被写入状态元件，并输出到随后的组合逻辑电路进行处理，经过
若干级门延迟，得到的处理结果被送到下一级状态元件的输入端，然后必须稳定一段时间才能开始下个时钟周期，并在时钟周期信号到达后还要保持一段时间


===多周期处理器===
    = 每条指令在多个时钟周期内完成；由此引入了 硬连线控制器 和 微程序控制器
    = 硬连线控制器：控制信号生成速度较快，适合RISC这种简单、规整的指令系统；对于CISC，其结构庞杂、实现困难、维护不易、扩充和修改困难
    = 微程序控制器：适用于CISC；将每条指令的执行过程用一个微程序表示；每个微程序由若干条微指令组成；每条微指令相当于有限状态机的一个状态
        所有指令对应的微程序都存放在一个ROM(CPU)中，称为控制存储器(控存)，里面的信息称为微代码
        = CPU从控存中取出每条指令对应的微程序，在时钟信号的控制下，按照一定的顺序执行微程序中的每条微指令；
        = 通常一个时钟周期执行一条微指令
    = 微操作、微命令：一条指令的功能通过执行一系列基本操作来完成，这些基本操作称为微操作；
        每个微操作在相应的控制信号的控制下执行，这些控制信号在微程序设计中称为微命令
    = 微指令字 称为 控制字(CW)

    = 微指令编码方式：不译法(直接控制法)、字段直接编码法(000作为不执行指令的作用)、间接编码法、最小(最短/垂直)编码法
        = 微指令互斥，指的是不能并行执行，属于同一个互斥类的微指令，都是互斥的
        = 互斥的放在同一段中，相容的分在不同段中，以便于并发执行

    = 微指令格式：水平型、竖直型


    = Intel处理器采用硬连线和微程序相结合的方式实现控制器


===中断===
    = 中断：硬件负责检测和响应；软件负责具体的处理过程

    = CPU检测异常的时机：
        = 在指令译码时，会检测指令操作码是否合法
        = 在取指令或取数据时，会检测是否发生了缺页或访问越权等存储保护错
        = 执行整数除法指令时，会检测除数是否为0
        = 在每条指令执行结束时，会检测有没有中断请求
    = 一旦检测到异常/中断时，CPU就会进入异常/中断响应过程
        = CPU完成以下两个任务：保护断点和程序状态、识别异常/中断类型并转相应处理程序执行
            = 保护断点和程序状态
                = 如果支持中断嵌套，则断点保存在栈中；反之，保存在特定寄存器中
            = 识别异常/中断类型并转异常处理 
                = 大多数处理器会采用软件识别内部异常；软件或硬件识别外部异常
                    = 软件识别：CPU设置异常状态寄存器，记录异常原因；os用异常查询程序，按一定优先级顺序查询异常状态寄存器；先查到的先处理
                    = 硬件识别/向量中断：内部异常可以在执行指令时发现，直接得到异常类型，根据类型号转去处理
                = 外中断无法在执行时检测到，只能CPU执行完一条指令后去检测

===指令流水线===
    = 流水线设计原则：指令流水段个数以最复杂指令所用的功能段个数为准；流水段长度以最复杂的操作所花时间为准    
    = 动态流水线、静态流水线

===加速比===
    = 不使用流水线的时间 / 使用流水线的时间

===吞吐率===
    = 单位时间内，流水线所完成的任务数量
    = tasks_cnt / all_time



===高级流水线技术===
    = 超流水线技术：通过增加流水线级数(完成指令的步骤)来使更多的指令同时在流水线中重叠执行
    = 多发射流水线技术：同时启动多条指令独立运行来提高指令并行性
        = 指令打包、冒险处理
        = 错误检测、回退机制
        = 推测：
            = 软件推测：编译器重排指令静态推测(一定要正确)
            = 硬件推测：处理器动态推测，调度指
    = 动态多发射处理器(超标量处理器)
        = 可以乱序执行
        = 编译器仅改变指令顺序，不需要根据机器结构进行指令打包
    = 静态多发射处理器：编译器根据硬件结构预测


===并行处理系统分类
    = Flynn分类
        = 单指令流单数据流(SISD)结构：仅包含一个处理器和一个存储器；一段时间只处理一条指令；所以引入指令流水线
            = 前面介绍的结构就是SISD
        = 单指令流多数据流(SIMD)结构：一个指令流同时对多个数据流进行处理
            = MMX(多媒体扩展)指令集、流式SIMD扩展指令集等都是数据级并行处理技术
        = 多指令流单数据流(MISD)结构：同一时刻有多个指令在执行，并且处理的是同一个数据；
            = 仅作为理论模型提出
        = 多指令流多数据流(MIMD)结构：同时有多个指令分别处理多个不同的数据；此系统一定包含多个计算机或多个处理器
            = 目前大多数并行处理系统的处理方式

    = 按地址空间的访问方式划分
        = 多计算机系统/消息传递系统：具有多个私有地址空间的系统；
            = 分布式存储器访问方式；
            = 一个计算节点通过消息机制访问另外一个计算结点的内存
        = 多处理器系统：共享存储多处理器系统，具有共享的单一地址空间的系统

    = 按存储访问时间是否一致划分
        = 一致性内存访问(UMA)结构：每个处理器访问所有存储单元的时间是一致的
        = 非一致性内存访问(NUMA)结构：处理器对不同的存储单元的访问时间可能不一致

    = 按处理单元的位置及其互联方式划分
        = 多核芯片：在一个CPU芯片中包含多个处理单元，每个处理单元称为核；所有核可能共享一个LLC(last-level cache)，并共享主存储器
        = 众核芯片：GPU设计着力于在众多的简单核上有效的执行众多的并行线程，并在线程组之间对数据的并行处理进行优化
            = 面向三维图形、视频和可视化处理的GPU(graphics processing unit)芯片，包含多达几百甚至上千个简单核
        = 对称多处理器：将多个相同类型的CPU通过总线互连，并等同地位地共享系统所有资源；无主次关系
        = 大规模并行处理机MPP(massive parallel processing)：以专用内联网络连接数量众多处理单元而构成的一种并行计算系统    
        = 集群：通过高性能网卡将若干普通PC或SMP服务器连接而成的并行处理系统
        = 网格：用因特网等广域网连接起来的远距离分布的一组异构计算机系统构成的分布式并行处理系统
            = 松散耦合的系统；云计算服务器就是由网格发展而来


===共享存储器的同步机制===
    = 顺序一致性模型：限制了处理器的访存指令执行顺序，影响性能
    = 宽松一致性模型：允许改变一个处理器内程序中对于不同存储器地址的访问指令的执行顺序
        = 需要存储器屏障(memory fence)指令，设置同步点，保证fence之前指令一定先执行完，才能执行fence后的指令
        = fence之前的一定在fence之前完成，之后的一定在fence之后完成
    = 释放一致性模型
        = acquire指令：它之后的所有访存指令都在它之后才能执行
        = release指令：在它之前的所有访存指令都必须在它之前执行完


===超线程===
    = 一个处理器或单个核中设置了两套线程状态部件，共享高速缓存和功能部件


                                        第七章、存储器层次结构
===以字节8bits编址===


===字的长度与机器字长相同===


===存储元件分类===
半导体存储器、磁性材料存储器、光盘存储器


===存取方式分类===
随机存取存储器RAM：用作cache、主存
顺序存取存储器SAM：磁带存储器
直接存取存储器DAM：兼 随机和顺序 访问，存取信息时，通常先寻找整个存储器中的某个小区域(如磁盘上的磁道)，再在小区域内顺序查找
按内容访问存储器/相联存储器CAM/AM：既可以按内容，也可以按地址存取


===信息的可更改性分类===
RAM、ROM均为随机存取


===按断电后信息的可保存性分类===
非易失性：ROM、磁表面存储器、光存储器
易失性：RAM、cache


===地址寄存器、地址译码器都在主存中===


===半导体随机存取存储器===
= 特点：体积小、存取速度快，适合作为内存
= 双极型RAM
= MOS型RAM
	静态RAM(SRAM)：六管静态MOS管存储元件，占硅片面积大，功耗大，集成度低，稳定、无须刷新、无需读后再生，读写速度快，
        价格昂贵，适合做高速小容量半导体存储器，如cache
	动态RAM(DRAM)：单管动态MOS管存储元件，会漏电、所以定期刷新，读操作使状态发生改变，需要读后再生，适合做慢速大容量的半导体存储器，如主存
		= 刷新方式
			= 集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器所有行进行逐一再生，在此期间停止读写
			= 分散刷新：对每行的刷新分散到各个工作周期中，增加了系统存取周期，降低机器速度，无死区
			= 异步刷新：结合前两种，缩短死时间
			= 整个存储器所有芯片同时刷新
		= 刷新通过刷新放大器来刷新的，集成在RAM中

= SRAM芯片：静态存储元件(双稳态电路的状态存储01，集成度低，成本高，功耗大，速度快，不采用地址复用，片选信号、读写控制信号)
= DRAM芯片：动态存储元件(电容存储01，集成度高，成本低，容量大，功耗低，速度慢，采用地址复用，有行/列选通信号，读写控制信号)


===存储器芯片由 存储体、IO读写电路、地址译码、控制电路 等部分组成===P210
= 存储器芯片组成：存储体、地址译码器、驱动器、IO控制电路、片选控制信号CS、读写控制信号WE


===存储体===
= 由n个位平面组成，由X选择线和Y选择线来选择所需单元；不同位平面的相同行和列上的位同时被读出或写入


===地址译码器===
= 一维译码：SRAM线选法、单译码法，适用于小容量的静态存储器；只有一个行译码器，一条线；同一行中所有存储单元的字 线连在一起，
    接到地址译码器的输出端，这种结构的存储器芯片称为 字片式芯片
= 二维译码：DRAM重合法、双译码法；一次只选一个位，称为位片式芯片；有行通选信号和列通选信号两条线，地址引脚复用
	= A11~A0中，A11~A6送至X译码器，A5~A0送至Y译码器；如000001 000000表示X=1，Y=0的线，选中了(1,0)单元；XY地址线可复用


===IO控制电路===
= 用于控制被选中的单元的读出或写入，具有放大信息的作用


===片选控制信号CS===
= 单个芯片容量太小，需要将一定数量芯片按特定方式连接成一个完整的存储器；
= 由芯片外的地址译码器的输入信号以及控制信号来产生片选控制信号，选中要访问的存储字所在的芯片；
= CS表示当片选信号为低电平时选中所在芯片


===行通选信号RAS，列通选信号CAS===
= 控制电路分时传送地址


===读写控制信号WE===
= WE表示当读写信号为低电平进行写操作，为高电平时进行读操作


===刷新周期===
= 上次对整个存储器刷新结束的时刻作为开始点到下次对整个存储器全部刷新一遍为止的时间间隔，也就是对某一个特定的行进行相邻两次刷新的时间间隔


   SDRAM芯片：同步DRAM
   EPROM：可擦除可编程只读存储器
   CD-ROM：光盘


===计算机主存===
= 通过存储器芯片的扩展技术，将多个芯片做在一个主存模块(即内存条)上，然后由多个主存模块以及主板或扩充板上的RAM芯片和ROM芯片组成一台计算机所需的主存空间


===DRAM芯片内部结构===
= 图中的为，16 * 8位，每片4 * 4，地址引脚采用复用方式，仅需两个地址引脚；
= 4 * 4个超元，每个超元有8位，需8位数据引脚，内部有行缓冲，用来缓存指定行中每一列的数据，通常用SRAM元件实现
= 连续传送的一块数据都在行缓存中，因而支持突发burst传送


===多模块/芯片存储器===
= 一种空间并行技术
= 连续编址方式(每读取一内存条上的一块内容，都需要时间来恢复电容DRAM)

	= 主存地址高位表示模块号或体号，低位表示模块内地址；地址在模块内连续
	= 存储器共有Mi个模块，每个模块有n个单元，模块Mi的地址范围为i * n ~ (i + 1) * (n - 1)
	= 总是把低位的体内地址送到由高位体号所确定的模块内进行地址译码
	= 缺点：当访问连续主存块时，总是先在一个模块内访问，等到该模块全部单元访问完才转到下一个模块访问，不能提高存储器的吞吐率
= 交叉编址方式
	= 主存地址低位表示模块号，高位表示模块内地址；
	= 每个模块有n个单元，则第i模块中的地址为：i，i + m，i + 2m...，i + (n - 1)m
	= 轮流启动
		= 如果每个存储模块一次读写的位数正好等于存储器总线中的数据位数，则采用此方式
		= 对于具有m个体/模块的多模块存储器，若每隔1/m个存储周期启动一个个体，一定时间后，每隔1/m个存储周期就可读出或写入一个数据，存取速度提高m倍
	= 同时启动
		= 如果所有存储模块一次并行读写的总位数正好等于存储器总线中数据位数，则可用此方式
		= 同时启动n个芯片，并行读写，显著提高访存速度


===DRAM扩展前，高6位输入行译码器，低6位输入列译码器；
===DRAM扩展后，再对地址进行进一步拆分，地址线条数进一步增加
===交叉编址存储器与这些无关，只要对 芯片/模块 编好号即可；其低位交叉并行，即指指令流水线并行


===位扩展法===
    连接方式：将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出；片选信号CS要连接到所有芯片


===字扩展法===
    连接方式：将芯片的地址线、数据线、读写控制线相应并联，由片选信号来区分各芯片地址范围；高位做片选信号，
        只需选中部分芯片，通过片选信号或采用译码器设计连接到相应芯片


===字位同时扩展法地址划分===
    =(x) 高位为组号，次高位为组内芯片，剩下是片内地址


===存储芯片的地址分配和片选===
    = 扩展或不扩展，先进行片选，再进行字选
    = 片选信号的产生
        = 先确定低位，再在低位上添加高位进行片选
        = 线选法：除片内寻址外的高位地址线分别接至各个存储芯片的片选端；当某地址线信息为0时，就选中与之对应的存储芯片，只允许1位有效
        = 译码片选法：将74LS138作为地址译码器，3位二进制数产生的8种情况，均可作为片选信号


===磁盘存储器的结构===
== 磁盘IO设备较为特殊，需要寻道、旋转，读取等操作，所以需要通过磁盘控制器接收的命令来传递给磁盘驱动器去寻找；
== 其他IO设备则只需IO控制器即可
== 磁盘存储器：主要由磁记录介质、磁盘驱动器、磁盘控制器
== 设备控制器通常独立于外部设备，集成到主板上或以插卡的形式插接在IO总线扩展槽上
    但也可以不独立于外部设备，而是作为独立的外部设备


= 磁道从外到里编址，最外面为磁道0
= 磁盘读写指根据磁盘地址寄存器中的盘地址读写目标磁盘中的指定扇区
= 磁盘控制器把地址送到磁盘驱动器，进行寻道
= 磁盘控制器是主机与磁盘驱动器之间的接口；磁盘存储器是高速外设，所以磁盘存储器和主机之间采用成批数据交换方式
= 温切斯特磁盘的磁道记录格式
	每个扇区(600B)：
		头空17字节，不记录数据，全1；留给磁盘控制器做准备用的，简化和方便磁头的辨识
		ID域：有同步字节、磁道号、磁头号、扇段号和相应的CRC码组成
		数据域：占515字节，有同步字节、数据和相应的CRC码组成，真正数据区占512字节
		尾空20字节，全1；在数据块的CRC码后的区域


===磁盘存储器的性能指标===
= 记录密度：道密度、位密度
= 存储容量
= 数据传输速率：指磁盘存储器完成磁头定位和旋转等待以后，单位时间内从存储介质上读出或写入的二进制信息量；称为 内部数据/持续 传输速率
	外部传输速率：指主机中的外设控制接口 从/向 外存的缓存 读出/写入 数据的速度，由外设采用的接口类型决定；也称为突发数据传输速率/接口传输速率
= 平均存取时间
	= 响应时间 = 排队时延 + 控制器时间 + 寻道时间 + 旋转等待时间 + 数据传输时间
	= 存取时间 = 寻道时间 + 旋转等待时间 + 数据传输时间
		= 数据传输时间 指传输一个扇区的时间；
		= 寻道和旋转等待只能取平均值；旋转平均等待时间取磁盘旋转一周所需时间的一半
		= 由于数据传输时间比前两个短，可以忽略


===磁盘存储器的连接===
= 现代计算机通常将复杂的磁盘物理扇区抽象成固定大小的逻辑块，物理扇区与逻辑块之间的映射由 磁盘控制器 控制 磁盘驱动器 维护
= 磁盘与主机交换数据的最小单位是一个扇区；这种高速成批数据交换设备采用 直接存储器存取DMA方式进行数据的输入和输出
	= 用专门的DMA接口硬件来控制外设与主存间的直接数据交换，数据不通过CPU
	= DMA控制器：专门用来控制总线进行DMA传送的接口硬件


===系统启动用到的BIOS是永久保存在ROM中的，现在的主板都用Flash存储器芯片来存储BIOS；可以进行擦除重新写入===


===烧录器写入方式只读存储器===
MROM、PROM、EPROM、EEPROM


===磁盘冗余阵列RAID===
= 将多个独立的物理磁盘驱动器按某种分方式组织成磁盘阵列，以增加容量，在os下这些物理磁盘驱动器被视为单个逻辑驱动器
= RAID使磁盘并行工作，提高数据传输速度；并利用RAID进行错误恢复以提高系统可靠性
===RAID===
= RAID0 没有冗余盘，即无校验信息
= RAID1 采用镜像盘实现一对一冗余，读取定位时间更少的磁盘提供数据、对两个磁盘中对应的信息并行更新
= RAID2 用海明码校验生成多个冗余校验盘，校验盘与数据盘成正比，因而冗余信息开销太大，价格贵
= RAID3 按位奇偶校验生成单个冗余盘，采用小条带交叉分布方式，数据传输速率高，但IO响应时间长
= RAID4 按位奇偶校验生成单个冗余盘，大数据块交叉分布方式，每个磁盘操作独立进行，所以多个小数据量操作可以在多个磁盘上并行进行，以同时响应多个IO请求，具有较快的IO响应
= RAID5 校验块分布在各个磁盘中，提高容错；独立存取技术、大数据块交叉分布方式；成本不高效率高，广泛用于服务器中
= RAID6 允许双盘出错
= RAID7 6的基础上引入cache




===Flash存储器/闪存===
= 存储元由MOS管组成，半导体存储器
= 高密度非易失性读写存储器，兼有RAM和ROM优点，功耗低、集成度高、不需后备电源
= 沿用了EPROM的简单结构和浮栅/热电子技术注入的编程写入方式，又兼备EEPROM的可擦除特点，且可在计算机内进行擦除和编程写入，又称为快擦型EEPROM
= 目前U盘、存储卡都属于Flash
= 其读取速度与半导体RAM芯片相当，基于随机访问；而写速度则比RAM芯片慢很多
= 基于电信号控制


===固态硬盘===
= 使用NAND闪存组成的外部存储系统，与U盘并没有本质区别，只是容量更大，存取性能更好；
= 用闪存颗粒替代了磁盘作为存储介质
= 以区块写入和抹除的方式进行数据的读取和写入
= 有均化磨损逻辑电路 延缓SSD寿命
= 开机速度快很多


===cache===
= 由SRAM组成、直接制作在CPU芯片内，速度几乎和CPU一样快
= cache和主存空间都被划分为相等的区域；
= 主存中的区域称为块/主存块，是cache与主存之间信息交换单位；
= cache中存放一个主存块的区域称为行或槽
= 有效位，指明其中块的有效性
= 对程序员透明


===cache行与主存块之间的映射方式===

### 高位为块号，将块号拆分开来，是tag位和组号/cache块号


= 目前是基于查找，并不是写操作
= 直接映射：也称模映射；cache行号 = 主存块号 mod cache行数
	= 假定cache有2^c行，主存有2^m块；即主存块号的低c位正好是它要装入的cache行号
	= 访问过程：主存tag与cache比较，相等 && 有效位为1，命中
	= 优点：容易实现、命中时间短
	= 缺点：引起频繁的调进调出，命中率较低
= 主存地址 ：tag(t=m-c，块群个数) + cache行号(c，2^c行) + 块内地址(512B，2^9，9位)	
= 全相联
	= 主存地址 ： tag + 块内地址
= 组相联
	= 将cache所有行分成2^q个大小相等的组，每组有2^s行；每个主存块被映射到cache固定组中的任意一行；即组间模映射、组内全映射方式
	= cache组号 = 主存块号 mod cache组数
	= 主存地址 ： tag + cache组号 + 块内地址
= 组相联下，根据主存块号取模无法映射，只能分解地址
= 各种映射结构，是主存地址的拆解，映到cache后，有特定的cache地址对应，而cache中有：有效位，修改位，数据位，标记位，(替换控制位)

===cache替换策略===
= 先进先出算法FIFO
= 最近最少使用算法LRU
	= 内含LRU位计数器，选择淘汰哪个主存块
	= LRU替换策略：需要记录每个cache行的生存时间，所以标记项还有logn位替换控制位，n路有log2 n
= 最不经常使用算法LFU
	= 也有替换位
= 随机替换算法
=频繁换入换出，称为簸箕或抖动


===cache写命中策略===
1、全写法：当CPU对cache写命中时，必须把数据同时写入cache和主存，当某一块需要替换时，不必把这一块写回内存，用新调入的块直接覆盖即可(不需要修改位，只有有效位)
2、回写法：当CPU对cache写命中时，只把数据写入cache，而不立即写入主存，只有当此块被换出时才写回内存(有修改位和有效位)
# cache写不命中策略：
1、写分配法：加载主存中的块到cache中，然后更新这个cache块
2、非写分配法：只写入主存，不进行调块
tip：非写分配法与全写法合用，写分配法与回写法合用

= 分离指令cache和数据cache的目的：减少指令流水线资源冲突

===虚拟存储器===
= 没有虚存的硬件，结构比较简单，指令执行速度较快，嵌入式大多不采用虚存
= CPU通过存储器管理部件MMU将指令中的逻辑地址转换为物理地址
= 分页式虚拟存储器
	= 缺页开销大，必须提高命中率；所以采用全相联；一致性问题，使用回写法
	= 页表来描述映射关系
	= 页表项：虚拟页存放位置、装入位(valid)、修改位(dirty)、使用/替换控制 位、访问权限位、禁止缓存位
	= 页表属于进程控制信息，位于虚拟地址空间的内核空间
	= 页表在主存的首址记录在页表基址寄存器中
	= 地址变换过程：根据页表基址寄存器找到主存中的页表，然后将虚拟地址高位字段中的虚页号作为索引，找到对应页表项，若装入位为1，取出；否则缺页异常
	= 快表/后备转换缓冲器TLB：相联存储器；
			高速缓存中，全相联或组相联；每个表项由页表项内容+TLB标记字段；随机替换策略
		= CPU首先查找TLB进行映射，随后再查找cache，然后找主存、最后找外存

	= 低位作为页内偏移、高位作为tag与页表比较，然后替换

===cache缺失处理由硬件完成、缺页处理由软件完成、TLB软硬件皆可===


= 分段式虚拟存储器
	= 段：段名、段起点、段长
	= 进程中有段表：对应段在主存中的位置、段长、访问权限、使用、装入情况
	= 段表可存在外存，需要时调入主存，一般驻留在主存中
	= 虚拟地址 = 段号 + 段内地址


= 段页式虚拟存储器
	= 程序按模块分段、段内分页
	= 段表项：段页表起始位置的指针，该段的其他控制和保护信息
	= 由页表指明该段各页在主存中的位置以及是否装入、修改等状态信息




# Cache主存系统的效率e＝访问Cache的时间 / 平均访存时间

# 死时间/访存死区：停止对存储器的读写操作的时间段

# 随机存取与随机存取存储器不同，只读存储器也是随机存取的；因此支持随机存取的存储器并不一定是RAM

# 四体交叉存取冲突：若给定的访存地址在相邻的4次访问中出现在同一个Bank中，就会发生访存冲突，发生冲突后，后面一个等待，直到前面的结束

# 数据字：低位交叉存取，模块中的单元 

# 片选与字选：CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选；然后为选中的芯片依地址选择相应的存储单元，以进行数据的存取，即进行字选

# 32K × 8bit指的是总容量32KB，32K个8bit，以字节编址；32K为地址索引，8为数据位数

# 字位同时扩展：低位用来表示组内地址，高位表示组号
   字扩展：低位表示字内地址，高位表示组号


# 主存单元地址：就是块号

# cache行大小，可以推 块内地址 位数

# 访问TLB时，虚页号高位部分用作TLB标记，低位部分用作TLB组号







						第八章、IO系统
=统一编址下，使用访存命令来处理输入输出

# IO端口：指IO接口中用于缓冲信息的寄存器

# 外部设备：由机械部分和电子部分组成，两部分通常可以分开，机械部分是外设本身，电子设备是设备控制器
	外设通过设备控制器连接到主机，设备控制器(显卡、网卡等)称为IO控制器、IO接口、或IO模块

# 常用的IO方式：程序查询、程序中断、DMA、通道

# 程序查询：信息交换的控制完全由CPU执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器(数据端口)和一个设备状态寄存器(状态端口)

# 程序中断：每传输一个字便进行中断处理
	中断请求：由中断源发出请求，每个中断源有对应的中断请求标记触发器，组成中断请求标记寄存器，可集中在CPU中，也可分散在各个中断源中
	中断响应判优(硬件排队器实现)：多个中断源同时请求时，进行判优；
	========优先级：不可屏蔽中断 > 内部异常 > 可屏蔽中断
			内部异常中：硬件故障 > 软件故障
			DMA中断请求优先于IO设备传送的中断请求
			IO传送中：高速设备优先于低速设备，输入设备优先于输出设备，实时设备优先于普通设备
	CPU响应中断的条件：CPU每次响应IO中断的时间是在每条指令执行阶段的结束时刻
	中断响应过程：CPU响应中断后，经过硬件实现某些操作(中断隐指令)，转去执行中断服务程序
		过程：
			1、中断隐指令：关中断、保存断点、中断服务程序寻址；
			2、中断程序(内核态)完成：保存现场和屏蔽字、开中断、执行中断服务程序、关中断、恢复现场和屏蔽字、开中断、中断返回
	中断向量：存储的是中断程序的入口地址
	
	不可屏蔽中断, 内中断即使在关中断情况下也会被响应
    = DMA > 外中断(不可/可屏蔽)

# DMA：
	DMA控制器/接口：对数据传送过程进行控制的硬件
	原理：当IO需要数据传送时，通过DMA控制器向CPU提出DMA请求，CPU响应后让出系统总线，由DMA控制器接管总线进行数据传送
	
# CPU和DMA请求总线使用权：
	1、停止CPU访存: 每个机器周期周期，进行DMA请求
	2、周期挪用(周期窃取)：每个存取周期，进行DMA请求
	3、DMA与CPU交替访存：CPU周期分为两段，前段DMA访存，后段CPU访存

# DMA优先于CPU：因为如果数据没有及时接收，会造成数据丢失

# 外设准备数据的时间应大于等于中断处理时间

# IO接口中的32位数据缓冲寄存器，每准备好32位数据，DMA控制器的总线使用权就发出一次总线请求

# 当DMA请求和中断同时发生时，优先响应DMA请求

# 磁盘访问时间：寻道时间 + 延迟时间(磁盘转半圈所需要的时间) + 传输时间(划过一个扇区的时间)

= 函数调用需要还原寄存器，还要改变PC；而跳转只需要改变PC
