 						操作系统引导
===os===
是一种程序，以数据的形式存放在硬盘中，硬盘通常分为多个区，一台计算机又有多个或多种外部存储设备

===os引导===
指计算机利用cpu运行特定程序，通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的os，最后通过程序启动os

===引导过程===
1、激活CPU：
	cpu读取ROM中的boot(启动)程序，开始执行BIOS指令
2、硬件自检：
	启动BIOS程序后自检，有故障：蜂鸣；无故障：显示cpu、内存、硬盘等信息
3、加载带有os的硬盘：
	BIOS读取boot sequence(启动顺序)，将控制权交给启动顺序第一位存储设备，cpu将该存储设备引导扇区的内容加载到内存中
4、加载主引导记录MBR：
	告诉cpu去硬盘的哪个主分区去找os(若无引导硬盘，死机)
5、扫描硬盘分区表，并加载硬盘活动分区：
	MBR扫描硬盘分区表，找到硬盘活动分区(含有os的分区)，加载活动分区，将控制权交给活动分区
6、加载分区引导记录PBR：
	读取活动分区的第一个扇区(分区引导记录PBR)
7、加载启动管理器
	PBR寻找并激活分区根目录下用于引导os的程序(启动管理器)
8、加载os


1)执行顺序依次是 ROM 中的引导程序、磁盘引导程序、分区引导程序、操作系统的初始化程序。
启动系统时，首先运行 ROM 中的引导代码（ bootstrap )。为执行某个分区的操作系统的初始化程序，
需要先执行磁盘引导程序以指示引导到哪个分区，然后执行该分区的引导程序，用于引导该分区的操作系统。

2)4个操作的执行顺序依次是磁盘的物理格式化、对磁盘进行分区、逻辑格式化、操作系统的安装。
磁盘只有通过分区和逻辑格式化后才能安装系统和存储信息。物理格式化（又称低级格式化，通常出厂时就已完成）
的作用是为每个磁道划分扇区，安排扇区在磁道中的排列顺序，并对已损坏的磁道和扇区做"坏"标记等。随后将磁盘的整体存储空间划分为
相互独立的多个分区（如 Windows 中划分 C 盘、 D 盘等），这些分区可以用作多种用途，如安装不同的操作系统和应用程序、存储文件等。
然后进行逻辑格式化（又称高级格式化），其作用是对扇区进行逻辑编号、建立逻辑盘的引导记录、文件分配表、文件目录表和数据区等。
最后才是操作系统的安装。

3)由上述分析可知，磁盘扇区的划分是在磁盘的物理格式化操作中完成的，文件系统根目录的建立是在逻辑格式化操作中完成的。

						
						第一章---操作系统引论
===os抽象===
IO设备管理软件实现了对计算机硬件操作的第一个层次的抽象
文件管理软件作为第二层抽象


===发展过程===
最开始硬件珍贵，注重效率；后来硬件价格下滑，为了人们使用门槛低，引入交互、图形界面、多媒体、网络、微机
随着CPU的改进，os也跟着改进
=======提高资源利用率=======
1、人工操作方式(裸机)：人工将纸带装入纸带输入机，再将纸带上程序和数据输入计算机，启动计算机运行
2、脱机输入输出(外围机)：解决人机矛盾；脱离主机情况下进行IO与CPU交互，由外围机控制将纸带上程序输入到磁带，CPU从磁带高速调入内存
	(联机输入输出：在主机的直接控制下进行交互)
3、单道批处理系统(第二代晶体管)：把一批作业以脱机方式输入到磁带上，由监督程序控制下，一个接一个执行
4、多道批处理系统(小规模集成电路)：用户作业在外存排队，由作业调度程序选择作业调入内存
=======提高可用性=========
5、分时系统：增加人机交互、及时性；配置多路卡，实现分时多路复用；作业直接进入内存、轮转运行
6、实时系统：实时性
	6.1、周期性实时任务：要求计算机按指定周期循环执行，以便周期性控制某外设
	6.2、非周期性实时任务：每个任务设置一个截止时间
	6.3、硬实时任务HRT：必须在截止时间之前完成
	6.4、软实时任务SRT：偶尔错过任务的截止时间，对系统性能的影响也不会太大

===微机操作系统(配置在微型机上的os)===
单用户单任务os(16位微机)：CP/M、MS-DOS
单用户多任务os(32位微机)：Windows，引入图形化
多用户多任务os： UNIX，最有影响的两个能运行在微机上的UNIX变型：Solaris os Linux(针对80386cpu开发的) os

===操作系统功能===
基本功能：处理机管理功能、存储器管理功能、设备管理功能、文件管理功能
新功能：系统安全、网络功能和服务、支持多媒体

===操作系统与用户之间的接口===
1、用户接口：联机用户接口、脱机用户接口、图形用户接口；使用户操作作业更为方便
2、程序接口：用户程序执行时访问系统资源，使用系统资源的唯一途径；
	早期由汇编编写，只能由汇编程序直接使用系统调用；
	近几年系统调用本身已经采用c语言编写，库函数形式提供
	本质上os提供的还是系统调用而不是库函数

===os结构设计===
无结构os：单人制作、注重效率
模块化结构os：os结构清晰，模块-接口法，无序不可靠
分层式结构os：将模块-接口法由无序转换为有序、性能降低
C/S模式：数据分布处理、便于集中管理、灵活可扩充、易于改编
面向对象

===宏内核===
所有os软件均存放在核心态

===微内核os结构===PC都是
= 基于模块化、层次化、C/S、面向对象的基础上
= 由微内核和多个进程管理服务器组成
= 将最主要的内容放入内核、剩下放入服务器中实现：文件管理进程、IO管理进程、虚存管理进程服务器等，运行在用户态
= 借助微内核提供的消息传递机制来实现信息交互
1、可以有效支持多处理机运行，适用于分布式系统环境
2、足够小的内核、基于C/S模式、机制与策略分离、面向对象
3、基本功能：进程管理、低级存储器管理、中断和陷入处理；机制放入微内核、策略放入服务器
(有可能用户态、内核态切换频繁导致性能降低，客户 <-> os <-> 服务器(不在内核中) )

广义指令：即系统调用命令

内中断、外中断：由硬件实现

===os内核===
= 机制放入微内核、策略放入进程管理服务器
= 与硬件紧密相关的模块(中断处理程序)、各种常用设备的驱动程序、运行频率较高的模块(时钟管理、进程调度、模块公用的基本操作)、
	进程、线程间通信、进程切换、线程调度、多处理机间同步放入微内核中
	都安排在紧靠软件的层次中，将它们常驻内存，称为os内核
= 功能：
	1、支撑功能：
		中断处理
		时钟管理(CPU主脉冲信号产生，os管理)
		原语操作：内核态，常驻内存
	2、资源管理功能：	
		进程管理、存储器管理、设备管理

===原语===
= 系统中的设备驱动、CPU切换、进程通信等功能中的部分操作都可定义为原语
= 处于os最底层，最接近硬件；运行具有原子性；运行时间短，运行频繁

===用户态、核心态===
= 为了防止os本身及关键数据遭受到应用程序有意或无意的破坏，将处理机的执行状态分成系统态和用户态两种
= 核心态：具有较高特权，能执行一切指令，访问所有寄存器和存储区
= 用户态：仅能执行特定指令，访问特定寄存器和存储区
= 应用程序运行在用户态，os内核程序运行在核心态
= 用户态转换到核心态，是由硬件完成的

===外核===类似于装双系统
= 不同于虚拟机克隆真实机器，而是对机器进行分区，给每个用户整个资源的一个子集
= 外核程序运行在内核态，为虚拟机分配资源，检查并确保没有机器会使用他人资源；
= 每个用户层虚拟机可以运行自己的os，但只能使用已申请并且获得分配的那部分资源

===虚拟机管理程序===
= 第一类：裸金属架构、类似双系统
= 第二类：寄居架构、VMware

						第二章---进程的描述与控制

===引入===
在设计多道程序os时，引入进程概念，达到并发

===进程实体/映像===
	程序段、数据段、PCB(进程表)
===进程状态===
	活动就绪：
		处于内存，等待获取cpu使用权
	活动阻塞：
		处于内存，IO请求、缓冲区申请失败等导致阻塞
	静止就绪：
		处于外存，等待调入内存
	静止阻塞：
		处于外存，等待调入内存
	执行：
		获取到cpu资源，正在运行的进程
	创建：
		申请空的PCB，填写控制和管理进程的信息，分配必备资源；最后转为活动就绪调入内存的就绪队列中
	终止：
		以后不能再运行，但os仍保留一个记录：状态码、计时统计数据，供其他进程收集；获取信息后，os删除该进程，将PCB清零，返还系统
		通常会在程序的最后安排一条Halt指令，用于向os表示进程运行结束

===PCB信息&作用===
	信息：
		1、进程标识符：外部标志符，用户创建如task；内部标识符，os创建，一串数字
		2、处理机状态信息：通用寄存器、指令计数器、程序状态字PSW、用户栈指针
		3、进程调度信息：状态、优先级、其他信息、事件(阻塞原因)
		4、进程控制信息
	
	作用：
		1、作为独立运行基本单位的标志：系统通过PCB来感知进程的存在
		2、能实现间断性运行方式：阻塞后，系统可将cpu信息保存在被中断进程的PCB中
		3、提供进程管理所需信息：记录有程序和数据在内存或外存中的始址指针，文件、IO、进程所需资源
		4、提供进程调度所需信息：记录进程状态、优先级、等待时间、已执行时间等
		5、实现与其他进程的同步与通信：设置有信号量、实现进程通信的区域、通信队列指针等

===进程控制块的组织方式===
1、线性方式：所有PCB组织在一张线性表中，该表首址存放在内存的一个专用区域中；每次查找扫描整张表
2、链接方式：相同类型PCB链接为各种队列
3、索引方式：根据其状态不同，建立不同索引表，将各索引表首址记录在内存的一些专用单元中

===进程间父子关系===
UNIX中进程有祖先关系，windows下，各进程地位相同

===进程控制===
1、一般是由os的内核中的原语来实现的

===进程通信方式===
将消息挂到目标进程的消息队列上，由目标进程利用接受命令从其消息队列中取出信息
1、共享存储器系统
	1.1、基于共享数据结构的通信方式：如任务队列；适用于少量数据，通信效率低下，属于低级通信
	1.2、基于共享存储区的通信方式：内存中开辟共享存储区，进程对共享区的读写来交换信息，实现通信
2、管道通信系统
	2.1、管道，即指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件
	2.2、向管道提供输入的发送进程以字符流形式将大量数据送入管道；而接受管道输出的接收进程则从管道中接收数据
    互斥(读写互斥)、同步、双方均在场
3、消息传递系统
	3.1、进程不必借助任何共享存储区或数据结构，而是以格式化消息message为单位，将通信的数据封装在消息中，并利用os提供的一组通信原语，在进程间通信
	3.2、是最广泛的一类进程通信机制，很好的支持多处理机系统、分布式系统和计算机网络
	3.3、直接通信方式
		= 直接通信原语
			= 对称寻址方式：ppp
			= 非对称寻址方式：c/s
		= 通信链路：用os原语建立链路
	3.4、间接通信方式
		= 信箱通信
			= 建立在RAM的公用缓冲区上
		= 信箱通信原语
4、客户机-服务器系统
	4.1、套接字
		= 最开始被设计用在同一台主机上多个应用程序之间的通信，主要是为了解决多对进程同时通信时端口和物理线路的多路复用问题；
		= 后来逐渐成为最流行的网络通信程序接口之一
		= 一个套接字就是一个通信标志类型的数据结构
		= 支持基于文件型和基于网络型通信
	4.2、远程过程/方法调用RPC
		= RPC是一个通信协议，该协议允许运行于一台主机系统上的进程调用另一台主机系统上的进程
		= 涉及到面向对象的调用时，成为远程方法调用
		= 为了实现RPC的透明性，引入存根stub概念；客户端有stub，服务器端也有stub与之关联，一般处于阻塞状态等待消息
		= 执行过程：本地进程 <-> 本地客户stub <-> 服务器调用完成 <-> 服务器stub <-> 本地进程

===线程===
1、线程本身不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源
2、线程控制块TCB
3、多个线程共享该进程所拥有的资源：相同的地址空间、可以访问进程拥有的资源

===线程实现方式===
os中所有进程，不论是系统进程还是用户进程，都是在其内核支持下运行的
内核支持线程：
	1、内核支持下运行，调度是以线程为单位进行的
	2、对于用户的线程切换而言，其模式切换的开销较大
	3、一个进程中的线程被阻塞，其他线程继续工作
用户级线程：
	1、无需内核支持，调度仍以进程为单位进行的
	2、允许每个进程定制自己的调度算法
	3、线程的实现与平台无关，甚至可以在不支持线程机制的os上实现
	4、大多数系统调用将使进程阻塞，当线程执行一个系统调用时，不仅该线程被阻塞，进程内所有线程都会阻塞；因为一次只能处理一个内核调用；所以后面引入多对多模型
	5、内核每次分配给一个进程的仅有一个cpu，进程中仅有一个线程能执行，其他等待
组合方式：多对一模型、一对一模型、多对多模型(用户级线程与内核线程之间的映射)
	根据用户级线程对应的内核线程数目n，分配n个线程控制块

===进程的封闭性===
是指进程执行的结果只取决于进程本身，不受外界影响

===引入线程后的进程===
= 引入：不把作为调度和分派的基本单位同时也作为拥有资源的单位，以做到轻装上阵；而对于拥有资源的基本单位，又不对之施以频繁的切换
1、进程是一个可拥有资源的基本单位（系统进行分派和调度的一个独立单位(引入线程前)）
2、进程已不再是可执行的实体，而把线程作为独立运行/调度的基本单位
3、进程切换时，需要保存大量上下文到PCB；而线程切换仅需保存和设置少量寄存器内容

每个线程都有它自己独立的线程上下文，包括线程ID、栈、栈指针、PC、条件码、通用目的寄存器值；
每个线程和其他线程一起共享进程上下文的剩余部分(用户虚拟地址空间、相同的打开文件的集合)



						第三章---处理机调度与死锁
===响应比===
(等待时间 + 服务时间) / 服务时间

===周转时间===
每个任务执行完毕后的时间的总和

===CPU利用率===
使用时间 / 整个过程完成的时间

===带权周转时间===
周转时间 / 服务时间

===调度层次===
高级调度：将《外存上处于后备队列中的作业》调入内存；用于多道批处理中，分时和实时不设置(但设置接纳控制措施)
低级(CPU)调度：决定就绪队列中的进程获得CPU
中级调度：也叫内存调度，存储器管理中的对换功能(内存不够时，选出换出的作业)

===作业调度===
先来先服务FCFS(first come first served)：作业、进程调度
短作业优先SJF(short job first)：作业、进程调度
优先级调度PSA(priority scheduling algorithm)：作业、进程调度
高响应比优先HRRN(highest response ratio next)：优先权 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间 = Rp

===进程调度===
轮转调度RR(round robin)
优先级调度PSA(priority scheduling algorithm)
多队列调度
多级反馈队列调度

===实时调度===
非抢占式调度：轮转、优先级
抢占式调度：基于时钟周期的优先级抢占调度
最早截止时间优先EDF(earliest deadline first)：非抢用于非周期实时任务，抢用于周期实时任务
最低松弛度优先LLF(least laxity first)：松弛度 = 必须完成时间 - 其本身的运行时间 - 当前时间
优先级倒置PIP(priority inversion problem)--可能出现的问题

===IO繁忙型任务优先权 大于 计算繁忙型任务===

===进程同步机制===
1、硬件同步机制
	提供一些特殊的硬件指令，允许对一个字中内容进行检测和修正，或者是对两个字的内容进行交换(双字比较-交换操作)
	1.1、关中断：锁测试之前关中断，完成锁测试并上锁后再开中断
		缺点：
		1.1.1、滥用会导致严重后果
		1.1.2、关中断时间过长，影响系统效率
		1.1.3、不能用于多CPU系统，一个CPU关中断并不能防止进程在其他CPU上执行相同的临界段代码
	1.2、test-and-set原子指令
	1.3、swap指令
		缺点：
		1.3.1、忙等，不符合让权等待
2、信号量同步机制
	2.1、整型信号量：整数表示资源数，容易忙等
	2.2、记录型信号量：wait与wakeup原语
	2.3、and型信号量：要么资源全分配完，要么不分配
	2.4、信号量集
3、管程机制
	自己写锁容易死锁，引入管程
	每次仅有一个进程进入管程，执行这组过程，使用共享资源
    条件变量实现互斥
	里面的条件变量也是抽象数据类型，保存了一个链表，用于记录因该条件变量而阻塞的所有进程

= 遵循的规则：空闲让进、忙则等待、有限等待、让权等待

===死锁===
产生死锁的必要条件：互斥、请求和保持、不可抢占、循环等待
处理死锁的方法：
    预防死锁：分配资源之前的策略；破坏死锁条件，主要是后三个
        = 破坏请求和保持条件
            1、一次全部分配完资源
            2、只分配初期资源，后续再动态获取
        = 破坏不可抢占条件
            如果获得某些资源后，又需要其他资源；则释放所有资源
        = 破坏循环等待条件
            对资源排序，按序申请资源
    避免死锁：动态分配资源过程中的策略；(银行家算法)
    检测死锁：(死锁定理)资源分配图切去边判断是否死锁
    解除死锁：抢占资源、终止进程(终止所有死锁进程、逐个终止进程)

===临界区===
共享变量段的代码程序
或每个进程中访问临界资源的那段代码

===临界变量===
共享数据

===管程===
定义了共享数据结构和各种进程在该数据结构上的全部操作

===PV操作===
分为PV前和PV后操作

===信号量===
互斥信号量定义为1，资源信号量定义为所需个数



						第四章---存储器管理
外存管理放到文件管理一章
===连续分配存储管理方式===
= 物理地址连续
	= 单一连续分配：单道程序环境下，内存分为系统区和用户区；系统区给os用，放在内存低址部分；用户区中仅装有一道用户程序
		单道下没有内存保护机制，就一个程序，不存在内存破坏，破坏os也不严重
	= 固定分区分配：多道程序环境下，将整个用户空间划分为若干个固定大小的区域，每个分区装入一个作业；各分区大小可相等或不相等
		为便于内存分配，通常将分区按其大小进行排队，并建立一张分区使用表，表项：各分区起始地址、大小、状态；
		当装入程序时，由内存分配程序根据用户程序的大小检索该表，找到满足的区
	= 动态分区分配
		 = 数据结构：描述空闲和已分配分区情况
			= 空闲分区表：记录每个空闲分区情况，表目：分区号、分区大小、分区始址等
			= 空闲分区链：实现对空闲分区的分配和链接，各分区起始部分：控制分区分配的信息，前向指针；分区尾部：后向指针
		= 算法：顺序搜索
			= 基于顺序搜索的动态分区分配算法（系统不太大）
				= 首次适应FF(first fit)：链以地址递增次序链接，每次从头，查找慢，内部碎片多
				= 循环首次适应NF(next fit)：减少内部碎片，但缺乏大的空间
				= 最佳适应BF(best fit)：长度递增
				= 最坏适应WF(worst fit)：每次选最大块，产生碎片可能性最小，查找效率高
                            块从大到小链接 
			= 基于索引搜索的动态分区分配算法（系统大）
				= 快速适应QF(quick fit)/分类搜索法：对块的容量进行分类，每类块大小相同；各设置分区链表，再设置一个管理索引表
					能保留大的分区，不会产生内部碎片；但算法复杂，系统开销大；以进程为单位分配，存在一定浪费
				= 伙伴系统BS(buddy system)：对2的幂大小块进行链接，分配：每次找2^n > 需；如果2^n没有，就把2^n+1拆开......；回收：类似
				= 哈希算法：构建一张以空闲分区大小为关键字的哈希表，映射到各个链表
        = 分区分配操作：	
            = 分配内存：如果程序很小，范围一个固定大小内存块；如果超过固定大小，则按需分配
            = 回收内存：合并相邻的块；
===紧凑===
= 把原来多个分散的小分区拼接成一个大分区的方法，但需对程序进行重定位；所以引入动态重定位
	= 动态可重定位分区分配
		= 紧凑后，MMU变换地址；
		= 系统中设有一个重定位寄存器
		= 与动态分区分配算法一样，只不过多了紧凑

===覆盖技术===
单道系统下的策略，把用户区分为固定区和若干覆盖区，经常活跃的部分放在固定区，其余部分按调用关系分段
首先将要访问的段放入覆盖区，其他段放在外存，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段
++特点++：
1、不必将进程全部信息装入主存 即可运行，但当同时运行程序的代码量大于主存时仍不能运行；
2、内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存
3、覆盖技术对用户和程序员不透明

===对换/交换===
= 用于单用户分时系统中，计算机内存小，分时将外存任务调入内存
= 是改善内存利用率的有效措施，可以直接提高处理机的利用率和系统的吞吐量
= 整体对换：对换整个进程(处于等待的进程调出，准备好的程序调入)
= 页面(分段)对换：请求分页、段
=对换空间的管理
	= 把磁盘空间分为文件区和对换区
		= 文件区：提高文件存储空间利用率为主，其次访问速度；离散分配方式
		= 对换区：提高进程换入换出速度，其次空间利用率；连续分配方式，较少考虑碎片问题
			= 也有空闲表：对换区首址和大小，盘块号和数表示

===离散分配存储管理方式===
= 由于紧凑需要较大开销，所以引入分页、段；再无需紧凑；一次性全部装入内存；

= 均有越界检测
1、分页存储管理方式：页号P(12 - 31)、位移量W(0 - 12)
	= 虚拟页号 -> 物理页号
	= 页表始址 + 页号 * 页表项长度 -> 该页项在页表中的位置 -> 物理块号 + 页内地址 -> 物理地址
	= 地址变换机构由硬件实现
	= PCB中的页表始址在运行时，会放入页表寄存器
《一级页表 表示最高级页表》

2、分段存储管理方式：段号(31 - 16)、段内地址(0 - 15)


3、段页式存储管理方式：用户程序分为若干段，再将每个段分为若干个页，并为每一个段赋予一个段名
		段号S + 段内页号 + 页内地址

===外部碎片===
动态分区产生，在分区的外部
===内部碎片===
固定分区产生，在分区内部



						第五章、虚拟存储器
===虚存特点===
1、运行速度接近于内存速度，而每位的成本却又接近于外存
2、虚拟存储器的实现，建立在离散分配存储管理方式的基础上

===请求分页存储管理方式===
= 请求页表机制：页号 + 物理块号 + 状态位P + 访问字段A + 修改位M + 外存地址

===最小物理块数===
= 保证进程正常运行所需的最小物理块数

===请求分页中的 内存分配和置换 策略===
= 固定分配局部置换：分配一组固定数据的物理块，缺页时，从固定页中调出一页；保证分配给该进程的内存空间不变
	= 缺点：很难确定固定数目块
= 可变分配全局置换：为进程先分配一定数目的物理块，运行期间可动态增加或减少；缺页时，增加一块，内存满了可将所有进程的任意一页调出
	= 缺点：其他进程缺页率增加
= 可变分配局部置换：如果频繁缺页，增加物理块；缺页率低，可以减少块数；剩下与固定分配局部置换相同

===调度算法===
1、页面置换算法
	= 最佳置换(无法实现，作为标准进行评估)
	= 先进先出
	= 最近最久未使用(每个页面配置一个8位移位寄存器定时左移，计算存在时间)，实现成本高
	= 最少使用：也配置移位寄存器，计算频率
	= clock置换：为每页设置一位访问位，再将内存中的所有页面都通过指针链接成一个循环队列
		= 当某页被访问时，其访问位被置为1；
		= 置换算法在选择一页淘汰时，只需检查访问位，如果是0，换出；如果是1，置0，再FIFO循环检查下一个
	= 改进clock置换：对于访问位A和修改位M
		= 1类A=0,M=0：最佳淘汰页
		= 2类A=0,M=1：并不是很好的淘汰页
		= 3类A=1,M=0：有可能再次被访问
		= 4类A=1,M=1：可能再被访问
		= 第一轮，寻找1类页，将第一个遇到的作为淘汰页，不改变访问位A
		= 第二轮，未找到1类页，寻找2类页，将第一个遇到的作为淘汰页；所有扫描过的页的访问位 置为0
		= 第三轮，未找到2类页，回到开始，所有访问位 置为0，重复第一轮

2、页面缓冲算法：设置两个链表   空闲页面链表：换出的页放在队尾，换进的页该表为其分配一个块
				修改页面链表：将修改的需要换出的页放在队尾

===Belady异常===
FIFO算法会产生所分配的物理块数增大而页故障数不减反增的异常现象

===工作集===
在某段时间间隔里，进程实际所要访问页面的集合

===请求分段存储管理机制===
= 段项：段名 + 段长 + 存取方式 + 访问字段A + 修改位M + 存在位P + 增补位 + 外存地址

===计算===
根据虚拟页号 -> 页框号，得到实际地址

虚拟存储最大容量：由计算机地址结构决定的，与主存和外存容量没有必然联系；编址空间大小取决于硬件的访存能力，一般由地址总线宽度决定
虚存的实际容量：受外存和内存容量之和限制

                                                                             
						第六章、IO系统
===驱动程序一旦发出IO命令，启动了一个IO操作后，驱动程序便把控制返回给IO系统，把自己阻塞起来，直到中断到来时再被唤醒；
= 具体的IO操作是在设备控制器的控制下进行的，因此，在设备忙于传送数据时，CPU又可以去干其他的事情，实现了CPU与IO设备的并行操作


===IO系统基本功能===
1、隐藏物理设备的细节
2、与设备的无关性
3、提高处理机和IO设备的利用率
4、对IO设备进行控制
5、确保对设备的正确共享
6、错误处理



===IO软件的层次结构===
1、用户层IO软件
2、设备独立性软件
3、设备驱动程序
4、中断处理程序
5、硬件

===IO系统中各种模块之间的层次视图===P194
1、IO系统的上下接口
	1.1 IO系统接口：是IO系统与上层系统之间的接口，向上层提供对设备进行操作的抽象IO命令，以方便高层对设备的使用
		而上层系统中有：文件系统、虚拟存储器系统以及用户进程等
	1.2 软件/硬件接口：其上面是->中断处理程序和用于却不同设备的设备驱动程序，下面是->各种设备的控制器
	1.3 上下两接口之间：IO系统

===IO系统的层次===
硬件 -> 中断处理程序 -> 设备驱动程序 -> 设备独立性软件 -> 用户层软件

===磁盘调度算法===
扫描算法(SCAN)、循环扫描算法(CSCAN)、NStepSCAN、FSCAN

===设备控制器===
= 内含若干个用于存放控制命令的寄存器和存放参数的寄存器，用户通过这些命令和参数，可以控制外部设备执行所要求的操作
= 含有与设备之间的接口和CPU之间的接口
= 驱动程序将IO命令转换为参数给控制器寄存器，然后控制器去执行
= 利用特定IO指令：缺点，访问内存和访问设备需要两种不同的指令
= 内存映像IO：内存和设备控制器中寄存器地址统一编址

= 分为字符控制设备、块控制设备

1、设备并不是直接与CPU进行通信，而是与设备控制器通信
2、功能：
	2.1 控制多个IO设备，实现IO设备和计算机之间的数据交换
	2.2 是CPU和IO设备之间的接口，接受从CPU发来的命令，去控制IO设备
3、类型：控制字符设备的控制器、控制块设备的控制器
4、基本功能：
	4.1 接收和识别命令
	4.2 数据交换
	4.3 标识和报告设备的状态
	4.4 地址识别
	4.5 数据缓冲区
	4.6 差错控制
5、是一种特殊硬件
6、组成：
	6.1 设备控制器与处理机的接口：CPU与控制器之间的通信
	6.2 设备控制器与设备的接口
	6.3 IO逻辑：用于实现对设备的控制(是一组控制线)；CPU利用IO逻辑向控制器发送IO命令，控制器接收IO逻辑进行地址译码

===IO通道===
= 一种硬件技术，价格昂贵，所以设置的通道较少，引起资源竞争严重；
= 解决瓶颈的方法：增加通路，通道数不变
= 流程：在设置了通道后，CPU只需向通道发送一条IO指令，通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了规定的
    IO任务后，才向CPU发中断信号
1、是一种特殊的处理机，可以执行IO指令，并通过执行通道程序来控制IO操作
2、通道与CPU共享内存，通道程序放在主机内存中
3、通道类型：
	3.1 字节多路通道：含有多个非分配型子通道，每个子通道连接一台IO设备，并控制该设备的IO操作
			这些子通道按时间片轮转方式共享主通道
		弊端：不适合连接于高速设备
	3.2 数组选择通道：可以连接多个高速设备
		弊端：只含有一个分配型子通道，一段时间内只能执行一道通道程序
	3.3 数组多路通道：前两种优点相结合

===中断===
1、外中断(中断)：中断由外部设备引起的
2、内中断(异常)：由CPU内部事件所引起的


===中断向量表===
= 每种设备配以相应的中断处理程序
1、存放各种设备的中断处理程序地址，表项为中断号
2、表则存放在异常表基址寄存器中


===中断处理程序处理过程===
1、测定是否有未响应的中断信号，程序每当执行完当前指令后，处理机都要测试是否有未响应的中断信号；若没有，继续往下执行；若有，则停止原有进程的执行，
    准备转去执行中断处理程序，为把CPU控制权转交给中断处理程序做准备
2、保护被中断进程的CPU环境，CPU控制权交给中断处理程序之前，应该先保存被中断进程的CPU环境
    = 由硬件自动保存PSW和PC到中断保留栈
    = 然后将所有寄存器压入中断栈中
3、转入相应的设备处理程序：将相应的程序地址放入PC
4、中断处理
5、恢复CPU的现场并退出中断


===设备驱动/处理程序===
= 对于不同设备，配置不同驱动程序
1、是IO系统/CPU与设备控制器之间的通信程序
2、功能：
	2.1 接收由 "与设备无关的软件" 发来的命令和参数
	2.2 检查用户IO请求的合法性
	2.3 发出IO命令
	2.4 及时响应由设备控制器发来的中断请求，调用中断处理程序进行处理
3、特点：
	3.1 是实现在与设备无关软件和设备控制器之间通信和转换的程序
	3.2 与设备控制器以及IO设备的硬件特性紧密相关
	3.3 与IO设备所采用的IO控制方式紧密相关
	3.4 驱动程序与硬件紧密相关，很多驱动程序固化在ROM中
	3.5 允许可重入
4、设备处理方式
	4.1 为每一类进程设置一个进程，专门用于执行这一类设备的IO操作
	4.2 在整个系统中设置一个IO进程
	4.3 不设置专门的设备处理进程，只为各类设备设置相应的设备驱动程序
5、处理过程：
	5.1 将抽象要求转换为具体要求
	5.2 对服务请求进行校验
	5.3 检查设备的状态
	5.4 传送必要的参数
	5.5 启动IO设备
6、对IO设备的控制方式
	6.1 使用轮询的可编程IO方式：CPU忙等，检测IO设备状态
	6.2 使用中断的可编程IO方式(字节为单位IO, 传输一字节，便中断一次)
	6.3 直接存储器访问方式
		6.3.1 特点：
			6.3.1.1 数据传输的基本单位是数据块
			6.3.1.2 所传送的数据是从设备直接送入内存的，或者相反
			6.3.1.3 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整个数据的传送是在控制器下完成的
		6.3.2 组成：主机与DMA控制器接口；DMA控制器与块设备接口；IO控制逻辑
		6.3.3 设置寄存器类型：命令/状态寄存器CR；内存地址寄存器MAR；数据寄存器DR；数据计数器DC
		6.3.4 工作过程：
			 CPU向磁盘控制器发送命令
			 启动DMA控制器进行数据传送：磁盘传送到DMA控制器缓存中，再复制到内存
			 DMA完成后发出中断请求
	6.4 IO通道控制方式(DMA发展)
		1、数据传输基本单位是一连串的块
		2、通道是通过执行通道程序并与设备控制器共同实现对IO设备控制的
		3、通道程序由一系列通道指令所构成
		4、每条指令包含：操作码；内存地址；计数；通道程序结束位P；记录结束标志R
		
===与设备无关的IO软件===
1、设备分配中的数据结构
	1.1 设备控制表DCT：记录设备情况
		包含：设备队列队首指针；忙/闲标志；与设备连接的控制器表指针；重复执行次数
	1.2 控制器控制表COCT：记录控制器情况
	1.3 通道控制表CHCT：
	1.4 系统设备表SDT：记录了系统中全部设备的情况，每个设备占一个表目
		包含：设备类型、设备标识符、设备控制表、设备驱动程序入口地址
2、设备分配算法：先来先服务、优先级高者优先
3、基本的独占设备分配程序
	3.1 分配设备
	3.2 分配控制器
	3.3 分配通道

+++设备分配的数据结构之间的关系：SDT整个系统只有一张，它记录系统中全部设备的情况，是系统范围的数据结构；每个设备有一张DCT，
	系统为每个设备配置一张DCT，以记录本设备的情况；每个控制器有一张COCT，系统为每个控制器都设置一张用于记录本控制器情况
	的COCT；系统为每个通道配置一张CHCT，以记录通道情况；SDT中每个表目有一个指向DCT的指针，DCT中的每个表目有一个指向COCT
	的指针，COCT中有一个CHCT指针，CHCT中有一个COCt指针

===逻辑设备表LUT===
= 实现设备无关性
= 整个系统设置一张LUT(单用户下)
= 为每个用户设置一张LUT，用户登陆时，系统为之创建LUT，放入PCB中


===用户层的IO软件===
假脱机系统(Spooling)
	1、将一台物理IO设备虚拟为多台逻辑IO，从而允许用户共享一台物理IO设备
    = 与早期脱机os类似，当系统引入了多道程序技术后，完全可以利用其中一道程序，来模拟脱机输入时的外围控制机功能; 再利用另一道程序，模拟输出
    = 这样便可在主机控制下，实现以前的脱机输入和输出
    = 建立在通道技术和多道程序技术基础上，以高速随机外存作为后援存储器
	2、构成：
        输入井、输出井：由磁盘上开辟出来的两个存储区域，分别模拟输入输出时的磁盘；以文件的形式组织管理(井文件)
        输入缓冲区、输出缓冲区：内存中开辟的两个缓冲区
        输入进程、输出进程；
        井管理程序：控制作业与磁盘井的信息交换

===共享设备===
指一个作业尚未撤离，另一个作业即可使用，但每个时刻只有一个作业使用


===磁盘存储器结构===
= 低级格式化
    = 温切斯特磁盘的磁道记录格式
        每个扇区(600B)：
            头空17字节，不记录数据，全1；留给磁盘控制器做准备用的，简化和方便磁头的辨识
            ID域：有同步字节、磁道号、磁头号、扇段号和相应的CRC码组成
            数据域：占515字节，有同步字节、数据和相应的CRC码组成，真正数据区占512字节
            尾空20字节，全1；在数据块的CRC码后的区域

= 磁盘分区
    = 每个分区的起始扇区和大小都记录在磁盘0扇区的主引导记录分区表所包含的分区表中
    = 在这个分区表中必须有一个分区被标记成活动的(即引导块)，以保证能够从硬盘引导系统

= 高级格式化
    = 设置一个引导块、空闲存储管理、根目录和一个空文件系统


===文件系统布局===
= 整个磁盘：MBR + 分区表 + 磁盘分区
= 磁盘分区：引导块、超级块、空闲空间管理、i节点、根目录、文件和目录

= 主引导记录(Master Boot Record, MBR)：位于磁盘的0号扇区，用来引导计算机
    = MBR后面是分区表，该表给出每个分区的起始和结束地址，表中一个分区被标记为活动分区，计算机启动时，BIOS读入并执行MBR
    = MBR做的第一件事是确定活动分区，读入它的第一块，即引导块
= 引导块(boot block)：MBR执行引导块程序，负责启动该分区中的os
= 超级块(super block)：包含文件系统所有关键信息(FCB指针等)，计算机启动或文件系统首次使用时，会读入内存
= 空闲块信息



===虚拟文件系统VFS===
= 为用户程序提供了文件系统操作的统一接口



===磁盘调度算法===
= 目标：使磁盘的平均寻道时间最少
    ===早期磁盘调度算法===
        = 先来先服务FCFS
        = 最短寻道时间优先SSTF：访问的磁道与当前磁头所在的磁道距离最近，不保证平均寻道时间最短
    ===基于扫描的磁盘调度算法===
        = 扫描算法(SCAN)
            = 先从里向外，找到距离最近的磁道；再反过来
        = 循环扫描算法(CSCAN)
            = 规定磁头只能自里向外移动，到头后，在回到开头
        = NStepSCAN & FSCAN调度算法
            = 黏着：系统总是访问磁盘的某个磁道而不响应对其他磁道的访问请求
            = 解决"磁臂粘滞"(有些进程，频繁访问同一磁道，将这些请求分散到其他队列，和其他进程请求放在一起)
            = NStepSCAN
                = 将磁盘请求队列分成若干个长度为N的子队列，按FCFS处理子队列；
                    用SCAN处理子队列中的请求；
            = FSCAN
                = 分成两个子队列，一个是请求队列(SCAN处理)，另一个是新出现的请求队列




				
						第七章、文件管理
===文件系统===
管理外存文件的系统，在外存中

= 有结构文件 & 无结构文件
= 有结构，若干个相关记录组成
= 无结构，则被看成是一个字符流

===文件目录===
外存中

===目录项===
由文件名和指向索引结点(对应一个文件，是文件的描述信息)的指针组成
文件数上限以索引结点为限制

===IO设备===
被os视为特殊文件


===文件系统的层次结构===
用户程序 -> 文件系统接口 -> 对对象操纵和管理的软件集合 -> 对象及其属性

===与文件系统有关的软件层次===
= IO控制层：最底层，主要由磁盘驱动器等组成，也称为设备驱动程序层
= 基本文件系统层：主要处理内存与磁盘之间数据块的交换
= 基本IO管理程序：用于完成与磁盘IO有关的事务，如将文件逻辑块转换为物理块号，管理磁盘中的空闲块号，IO缓冲的指定等
= 逻辑文件系统：用于处理与记录和文件相关的操作，如允许用户和应用程序使用符号文件名访问文件及记录，实现对文件和记录的保护等


===open文件操作===
把指定文件的FCB复制到内存指定区域

===文件结构===
= 物理结构
    = 文件的存储结构，系统将文件存储在外存上所形成的一种存储组织形式，是用户不能看见的
        与存储介质的存储性能和所采用的外存分配方式有关
= 逻辑结构/文件组织
    = 从用户观点出发所观察到的文件组织形式
        文件是由一系列的逻辑记录组成，是用户可以直接处理的数据及结构
    = 基本要求
        = 有助于提高对文件的检索速度
        = 方便对文件进行修改
        = 降低文件存放在外存上占用的存储空间，不要求大片的连续存储空间
    = 结构分类
        = 有结构文件/记录式文件
            = 定长记录：所有记录长度相同
            = 变长记录
        = 无结构文件/流式文件
            = 源程序、可执行程序、库函数等，都是流式文件
    = 组织方式分类(也就是检索文件内容的方式)
        = 顺序文件
            = 一系列记录按某种顺序排列所形成的文件
            = 串结构：按存入时间的先后进行排序
            = 顺序结构：按关键字来排序
            = 记录寻址
                = 隐式寻址方式：Wptr = Wptr + L
                = 显式寻址方式：基于index索引，实现随即存取(定长)
        = 索引文件
            = 为可变长记录文件建立一张索引表，每个记录设置一个表项
        = 索引顺序文件
            = 为每个文件建立一张索引表时，为一组记录中的第一个记录建立一个索引表项
            = 直接文件：键值对随即查找
            = Hash文件

===目录管理===
= 要求
    = 按名存取
    = 提高对目录的检索速度
    = 文件共享
    = 允许文件重名

===文件控制块FCB===
= 文件控制块的有序集合成为文件目录
= 一个控制块就是一个文件目录项
= 三类信息
    = 基本信息：文件名、文件物理位置、文件逻辑结构、文件的物理结构
    = 存取控制信息：文件主的存取权限、核准用户的存取权限以及一般用户的存取权限
    = 使用信息：文件的建立时间和日期、文件上一次被修改的时间、当前使用信息

===索引节点(存放目录)===
= 文件目录：每个目录项仅由文件名和指向该文件所对应的i节点的指针所构成
= 由于查找文件时，是将目录取到内存读取，但只用到了文件名，但所有信息全拷贝出来了；
= 为此UNIX把文件名与文件描述信息分开；亦即，使文件描述信息单独形成一个称为索引节点的数据结构，简称为i节点；
===磁盘索引节点===
===内存索引节点===：文件被打开时，磁盘节点拷贝到内存节点中

===简单文件目录===
= 单级文件目录
    = 缺点：查找速度慢、不允许重名、不便于实现文件共享
    = 只适用于单用户环境
= 两级文件目录
    = 为每个用户独自创建用户文件目录UFD
    = 缺点：完全隔离，不便于多用户协作
===树形结构目录===



===文件共享(树形结构基础发展的)
= 基于有向无循环图实现文件共享
    = 允许每一个文件都可以有多个父目录
    = 但是单用户更改对其他用户透明
= 基于索引节点实现文件共享(硬链接)
    = 利用指针，使更改不透明
    = 利用引用计数来删除文件
= 基于符号链接实现文件共享(软链接)
    = 允许一个文件或子目录有多个父目录，但其中仅有一个作为主父目录，其他的几个父目录都是通过符号链接的方式与之相链接的
    = 只有文件主才有指向共享文件的指针，其他用户只有该文件的路径名



===文件保护===
= 措施
    = 存取控制机制
    = 系统容错技术
    = 建立后备系统
== 本章介绍第一种，下一章介绍后两种
= 规定，每一个进程仅能在保护域内执行操作，而且只允许进程访问它们具有访问权的对象
= 进程可以和域静态联系，也可以动态联系(增设保护域切换功能)


===访问矩阵===
= 基本的访问矩阵
    = 利用一个矩阵来描述系统的访问控制
    = 行代表域，列代表对象
    = aij是由访问权组成
= 具有域切换权的访问矩阵
    = 设立switch标志位，如果为s，则可以D1切换到D2
= 访问矩阵的修改
    = 增加拷贝权、拥有权、控制权
= 实现
    = 由于是稀疏矩阵，所以采用按列划分或按行划分，以分别形成访问控制表或访问权力表
    = 访问控制表(ACL)：当对象是文件时，便把访问控制表存放在该文件的文件控制表中，或放在文件的索引节点中
        = ACL也可用于定义缺省的访问权集，当某用户(进程)要访问某资源时，通常是首先由系统到缺省的访问控制表中，去查找该用户是否具有对指定资源进行访问的权利；
            如果找不到，再到相应对象的访问控制表中去查找
    = 访问权力表
        = 通常将访问权力表存储到系统区内的一个专用区中，只有通过访问合法性检查程序才能对该表进行访问，以实现对访问控制表的保护






						第八章、磁盘存储器管理
磁盘是存储设备的统称，硬盘是磁性硬盘驱动器的一种具体类型

===外存组织方式===
= 连续组织方式
    = 通常盘块存储在一条磁道上，顺序存储；也会产生外存碎片，但是"紧凑"比内存"紧凑"时间更慢
    = 优点：
        = 顺序访问容易
        = 顺序访问速度快
    = 缺点：
        = 外存碎片多，利用率不高
        = 紧凑 花费时间长
        = 必须事先知道文件的长度
        = 不能灵活的删除和插入记录
        = 对于动态增长的文件，一次会分配大片区域，造成存储空间长期空闲


= 链接组织方式
    = 优点：
        = 消除外部碎片，提高外存利用率
        = 对插入、删除和修改记录都非常容易
        = 能适应文件的动态增长
    = 隐式链接
        = 在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针；每个盘块又有指向下一个盘块的指针
        = 只适合于顺序访问
        = 通过指针链接，可靠性较差
        = 所以引入了簇，将几个盘块组成一个簇cluster；
            成倍减少查找指定块时间、减小指针所占用的存储空间、但是增大了内部碎片
    = 显式链接
        = 把用于链接文件各物理块的指针显式的存放在内存的一张链表(FAT文件分配表)中；该表在磁盘中仅设置一张
        = 表的序号为盘块号，表项为下一盘块号指针
        = 由于存放在内存，所以查找速度很快
        = 某文件的第一盘块号均被填入相应的FCB的物理字段中


= 索引组织方式
    = 由于FAT表占用大、不能直接存取
    = 实际上，在打开某个文件时，只需把该文件占用的盘块的编号调入内存即可
    = 为此应将每个文件所对应的盘块号集中的放在一起，在访问到某个文件时，将该文件所对应的盘块号一起调入内存
    = 为每个文件分配一个索引块，把分配给该文件的所有盘块号都记录在该索引块中
= 多级索引方式
    = 增加了访问磁盘的次数
= 增量式索引组织方式
    = 分为直接寻址、一级索引、二级索引......


===FAT技术===
= 引入了"卷"的概念，将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷(分区)
= 每个卷都专门划分出一个单独区域来存放自己的目录和FAT表，以及自己的逻辑驱动器字符(C: D: E:)
= FAT12
    = 早期的FAT12
    = 以盘块为基本分配单位，FAT是文件系统重要数据结构，为了安全，在每个分区都配有两张相同的文件分配表FAT1、FAT2
= FAT16
= FAT32(表项宽度为32位)
    = 不能保持向下兼容


===NTFS(New Technology File System)技术===
= 使用64位磁盘地址
= 支持长文件名
= 具有系统容错功能
= 能保证系统中的数据一致性
= 提供文件压缩、文件加密功能


===记录成组分解技术===
= 当文件的一个逻辑记录的长度小于一个物理块的长度的时候，可以把若干个逻辑记录合并成一组存到一个物理块中，这个工作称为成组
= 访问某个记录的时候，需要把这个记录从它所在的块中的一组记录中分离出来，这一工作成为分解


= 以簇为基本单位，一个文件含多个簇，一个簇仅属于一个文件
= 使NTFS具有了与磁盘物理块大小无关的独立性
= "卷因子"：卷上 簇的大小



===磁盘分簇的好处(以簇为基本分配单位)===
1、适应磁盘容量不断增大的情况；
2、减少FAT中的项数，使FAT占用更少内存空间，减少访问FAT的存取开销
3、提高文件访问速度
4、但会造成更大的簇内开销

磁盘地址默认取4B



===文件存储空间的管理===
= 磁盘分配表，记住可供分配的存储空间情况
    = 空闲表法
        = 属于连续分配方式
        = 为外存上所有空闲区建立一张空闲表
        = 每个空闲区对应一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息
        = 再将所有空闲区按其起始盘块号递增次序排序
        = 分配方式与内存类似
        = 外存适合连续分配，可以减少访问磁盘时间


    = 空闲链表法
        = 将所有空闲盘区拉成一条空闲链
            = 空闲盘块链
                = 以盘块为单位拉成一条链
                = 分配和回收简单，但是效率低，空闲盘块链会很长
            = 空闲盘区链
                = 将所有空闲盘区拉成一条空闲链
                = 缺点与前面相反


    = 位示图法
        = 利用m * n的二维数组，和二进制位表示盘块使用情况
        = 容易找到一个或一组相邻接的空闲盘块
        = 位示图占用空间小，所以存在内存


    = 成组链接法
        = 适用于大型文件系统
        = 空闲盘块号栈，存放一组空闲盘块的盘块号，以及栈中尚有的空闲盘块号数N
        = 文件区中的所有空闲盘块被分成若干个组
        = 将每组含有的盘块总数N和该组所有的盘块号记入其前一组的第一个盘块的S.free(0)~S.free(99)中，这样由各组的第一个盘块可链成一条链
        = 将每一组含有的盘块总数N和该组所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号
        = 最末一组只有99个可用块，放在S.free(1)~S.free(99)中，S.free(0)置0，作为结束标志



===提高磁盘IO速度的途径===
= 磁盘高速缓存
    = 数据交付方式
        = 数据交付，直接将高速缓存中的数据传送到请求者进程的内存工作区中
        = 指针交付，只将指向高速缓存中某区域的指针交付给请求者进程

    = 置换算法
        = 访问频率：联想存储器访问频率远远高于对磁盘高速缓存的访问频率
        = 可预见性：磁盘中各盘块数据，有相当一部分具有可预见性；例如，对二次地址和目录块等，在它被访问后，可能会很久都不再被访问；正在写入数据的未满盘块，
            可能会很快又被访问
        = 数据一致性：将磁盘高速缓存拉成一条LRU链；严重影响到数据一致性和很久不可能使用的盘块数据，都放在LRU链的头部
        = 周期性的写回磁盘：UNIX中增设了update程序，每30s将修改的盘块写回磁盘

===其他方法===
    = 提前读：顺序访问具有可预见性，提前读取下一盘块
    = 延迟写：修改A后，放入队尾；直到A到队头，当再有进程申请到该缓冲区时，才将缓冲区中数据写入磁盘
    = 优化物理块的分布：不能将文件安排的过于分散，增大了磁头移动距离；尽量在同一条磁道上
    = 虚拟RAM盘：利用内存空间去仿真磁盘，易失性，通常用于存放临时文件
    = 廉价磁盘冗余阵列RAID


===提高磁盘可靠性的技术===
= 第一级容错技术SFT-1：防止因磁盘表面缺陷所造成的数据丢失
    = 双份目录和双份文件分配表
    = 热修复重定向和写后读校验

= 第二级容错技术SFT-2：防止磁盘驱动器和磁盘控制器故障所导致的系统不能正常工作
    = 磁盘镜像：在同一磁盘控制器下，再增设一个完全相同的磁盘驱动器
    = 磁盘双工：将两台磁盘驱动器分别接到两个磁盘控制器上
    = 基于集群技术(对陈对台处理机SMP实现服务器功能)：提高系统并行处理能力和可用性
        = 双机热备份模式：备有两台服务器，一台作为主服务器，另一台作为备份服务器；一旦主server出错，备份接管主server，主server修复后作为备份
        = 双机互为备份模式
        = 公用磁盘模式：将多台计算机连接到一台公共的磁盘系统上，减少信息复制开销；每台计算机使用其中一卷，发生故障后，其他计算机接替其卷使用权

= 后备系统：磁带机、硬盘、光盘驱动器



===数据一致性控制===
= 与数据库的事务类似






						第九章、操作系统接口
库函数：是应用程序的一部分，运行在用户空间中；
系统调用：是操作系统的一部分，是内核为用户提供的程序接口，运行在内核空间中；可以访问内核中的栈
	陷阱提供了用户程序和内核之间的一个像过程一样的接口，叫做系统调用
系统开机后，os程序会被自动加载到内存中的系统区，这段区域是RAM
中断后运行的程序是os程序
从用户态到核心态的转换是由硬件完成的
用户态和核心态	与centos中的root和hsf的关系差不多
